<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Underwater Firefighter</title>
    <link rel="icon" href="data:,">
    <style>
      /* General Reset & Body */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body,
      html {
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #000408; /* even darker blue, almost pure black */
        font-family: monospace;
        color: #fff;
      }
      /* Canvas covers full viewport and sits at a low z-index */
      #gameCanvas {
        display: block;
        position: absolute;
        z-index: 1;
      }
      /* In-Game UI */
      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 10;
      }
      #ui > div {
        margin-bottom: 5px;
      }
      #ui #powerupTimers {
        font-weight: bold;
      }
      /* New City Health Bar inside UI */
      #cityHealthBarContainer {
        width: 200px;
        height: 20px;
        background: #555;
        margin-top: 5px;
        border: 1px solid #fff;
      }
      #cityHealthBar {
        height: 100%;
        background: green;
        width: 100%;
      }
      /* New Upgrade Timer UI Bar (top right) */
      #boostTimerUI {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 10;
        font-family: monospace;
        font-size: 16px;
        background: rgba(0, 0, 0, 0.5);
        padding: 5px 10px;
        border: 1px solid #fff;
        border-radius: 4px;
      }
      /* Full-Screen Tutorial/Store Overlay */
      #tutorial {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: #000;
        z-index: 20;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        overflow-y: auto;
        padding-top: 20px;
      }
      #tutorial .content {
        max-width: 1000px;
        padding: 30px;
        background: rgba(0,0,0,0.8);
        border-radius: 10px;
        border: 1px solid #00ffff;
      }
      /* ASCII Art Style Buttons for the Intro Page */
      .ascii-button {
        font-family: monospace;
        font-size: 16px;
        background: rgba(0,0,0,0.3);
        border: 2px solid #00ffff;
        padding: 8px 16px;
        margin: 5px;
        color: #00ffff;
        cursor: pointer;
        transition: all 0.3s;
      }
      .ascii-button:hover {
        background: #00ffff;
        color: #000;
      }
      /* Color Option Buttons */
      .color-option {
        display: inline-block;
        vertical-align: top;
        width: 40px;
        height: 40px;
        border: none;
        margin: 5px;
        cursor: pointer;
      }
      .selected {
        outline: 3px solid #fff;
      }
      .disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      /* Store Item Blocks - Add some spacing */
      .store-item {
        background: rgba(255,255,255,0.05);
        padding: 20px;
        border-radius: 8px;
        transition: background 0.3s;
      }
      .store-item:hover {
        background: rgba(255,255,255,0.1);
      }
      .store-item h4 {
        color: #00ffff;
        margin-bottom: 10px;
        font-size: 1.1em;
      }
      .store-item button {
        margin-top: 10px;
        width: 100%;
      }
      /* Game Over Overlay */
      #gameOver {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        background: rgba(0, 0, 0, 0.9);
        padding: 20px 30px;
        border-radius: 10px;
        z-index: 20;
        display: none;
      }
      #gameOver button {
        font-family: monospace;
        font-size: 1em;
        padding: 10px 20px;
        margin: 10px 5px;
        cursor: pointer;
      }
      /* Notification Container */
      .notification {
        position: absolute;
        top: 50px;
        width: 100%;
        text-align: center;
        font-size: 20px;
        pointer-events: none;
        z-index: 15;
      }
      /* Credit Link in Bottom Left */
      #creditLink {
        position: absolute;
        bottom: 10px;
        left: 10px;
        color: #fff;
        text-decoration: none;
        font-family: monospace;
        z-index: 10;
      }
      /* Level transition modal */
      .level-modal {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.95);
        padding: 30px;
        border: 2px solid #fff;
        color: #fff;
        text-align: center;
        z-index: 1000;
        min-width: 300px;
        font-family: monospace;
      }
      .level-modal button {
        margin-top: 20px;
        padding: 10px 20px;
        background: #fff;
        color: #000;
        border: none;
        cursor: pointer;
        font-family: monospace;
      }
      .level-modal button:hover {
        background: #ccc;
      }
      /* Add spacing between sections */
      .section {
        margin-bottom: 30px;
        padding: 15px;
        border-radius: 5px;
        background: rgba(0, 0, 0, 0.2);
      }
      /* Make the tutorial scrollable but keep header visible */
      #tutorial {
        overflow-y: auto;
      }
      #tutorial h1 {
        color: #00ffff;
        text-shadow: 0 0 10px #00ffff;
        margin-bottom: 30px;
      }
      .powerup-item {
        background: rgba(255,255,255,0.1);
        padding: 10px;
        border-radius: 5px;
        text-align: center;
      }

      .powerup-item p {
        margin: 5px 0;
        font-size: 0.9em;
      }

      .section h2 {
        color: #00ffff;
        margin-bottom: 15px;
        border-bottom: 1px solid #00ffff;
        padding-bottom: 5px;
      }

      .section h3 {
        color: #ffcc00;
        margin: 10px 0;
      }

      .section ul li {
        margin: 8px 0;
        line-height: 1.4;
      }

      /* Add Pause Button Styles */
      #pauseBtn {
        position: absolute;
        top: 10px;
        left: calc(300px + 20px); /* city.width + margin */
        z-index: 10;
        font-family: monospace;
        font-size: 24px;
        background: rgba(0, 0, 0, 0.5);
        border: 2px solid #00ffff;
        color: #00ffff;
        padding: 5px 15px;
        cursor: pointer;
        transition: all 0.3s;
      }
      #pauseBtn:hover {
        background: #00ffff;
        color: #000;
      }
      
      /* Pause Menu */
      #pauseMenu {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        padding: 20px;
        border: 2px solid #00ffff;
        z-index: 100;
        text-align: center;
      }
      #pauseMenu button {
        margin: 10px;
      }
    </style>
  </head>
  <body>
    <!-- Add Pause Button -->
    <button id="pauseBtn">‚è∏Ô∏è</button>
    
    <!-- Add Pause Menu -->
    <div id="pauseMenu">
      <h2>Game Paused</h2>
      <button class="ascii-button" id="resumeBtn">Resume</button>
      <button class="ascii-button" id="quitToMenuBtn">Quit to Menu</button>
    </div>

    <!-- In-Game UI -->
    <div id="ui">
      <div>Score: <span id="score">0</span></div>
      <div>Combo: <span id="combo">0x</span></div>
      <div>City Health: <span id="cityHealth">100/100</span></div>
      <!-- New City Health Bar -->
      <div id="cityHealthBarContainer">
        <div id="cityHealthBar"></div>
      </div>
      <div>Ship Health: <span id="shipHealth">3/3</span></div>
      <div>High Score: <span id="highScoreDisplay">0</span></div>
      <div>Powerups: <span id="powerupTimers"></span></div>
    </div>

    <!-- New Upgrade Timer UI (top right) -->
    <div id="boostTimerUI">Upgrades: None</div>

    <!-- Game Over Overlay -->
    <div id="gameOver">
      <p id="gameOverText">Game Over!</p>
      <button id="restartBtn" class="ascii-button">Restart</button>
      <button id="storeBtn" class="ascii-button">Return to Store</button>
    </div>

    <!-- Full-Screen Tutorial/Store Overlay -->
    <div id="tutorial">
      <div class="content">
        <h1>Underwater Firefighter</h1>
        <div class="section" style="text-align: left; padding: 20px; line-height: 1.5;">
          <h2>üåä Mission Background</h2>
          <p>
            The year is 2157. Rising sea levels have forced humanity to build vast underwater cities protected by advanced force fields.
            But even beneath the waves, the ancient threat of fire persists - taking new and dangerous forms in the depths.
          </p>
          <p>
            As an elite Aqua Fire Response Unit pilot, you are the city's last line of defense. Your advanced submersible is equipped
            with specialized water-projection technology and can be upgraded with cutting-edge weapons and defenses.
          </p>
        </div>

        <div class="section" style="text-align: left; padding: 20px;">
          <h2>üéÆ Controls</h2>
          <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 5px;">
            <h3>üíª Desktop:</h3>
            <ul style="list-style-type: none; padding-left: 20px;">
              <li>üéØ <strong>Move:</strong> WASD or Arrow Keys</li>
              <li>üíß <strong>Fire Water:</strong> Hold SPACE</li>
            </ul>

            <h3 style="margin-top: 15px;">üì± Mobile:</h3>
            <ul style="list-style-type: none; padding-left: 20px;">
              <li>üéØ <strong>Move:</strong> Left side virtual joystick</li>
              <li>üíß <strong>Fire:</strong> Tap/hold right side</li>
            </ul>
          </div>
        </div>

        <div class="section" style="text-align: left; padding: 20px;">
          <h2>‚ö†Ô∏è Threats</h2>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
            <div style="background: rgba(255,0,0,0.1); padding: 15px; border-radius: 5px;">
              <h3>üî• Normal Fires</h3>
              <pre style="color: #ff3300; margin: 10px 0;">
  FFF  
 FFFFF 
  FFF  </pre>
              <p>Extinguish with your water cannon</p>
            </div>

            <div style="background: rgba(0,255,255,0.1); padding: 15px; border-radius: 5px;">
              <h3>‚ö° Electrical Fires</h3>
              <pre style="color: #66ccff; margin: 10px 0;">
  EEE  
 EEEEE 
  EEE  </pre>
              <p>Requires Electric Hose or direct contact</p>
            </div>
          </div>

          <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 5px; margin-top: 20px;">
            <h3>‚ò†Ô∏è Hazards</h3>
            <div style="display: flex; justify-content: space-around; margin: 10px 0;">
              <div>
                <pre style="color: #ffffff">
  /M\  
 | M | 
  \M/  </pre>
                <p>Mines</p>
              </div>
              <div>
                <pre style="color: #cccccc">
   ___  
  / D \ 
  \___/ </pre>
                <p>Debris</p>
              </div>
            </div>
          </div>
        </div>

        <div class="section" style="text-align: left; padding: 20px;">
          <h2>üéØ Objectives</h2>
          <ul style="list-style-type: none; padding-left: 20px;">
            <li>üè∞ Protect the underwater city</li>
            <li>üî• Extinguish fires before they reach the shields</li>
            <li>üí™ Survive increasingly difficult waves</li>
            <li>üëë Defeat powerful bosses</li>
            <li>üí∞ Earn currency for upgrades</li>
          </ul>
        </div>

        <div class="section" style="text-align: left; padding: 20px;">
          <h2>‚≠ê Power-ups</h2>
          <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
            <div class="powerup-item">
              <span style="font-size: 24px;">üöÄ</span>
              <p><strong>Speed Boost</strong><br>Temporary speed increase</p>
            </div>
            <div class="powerup-item">
              <span style="font-size: 24px;">üíß</span>
              <p><strong>Hose Upgrade</strong><br>Wider water spray</p>
            </div>
            <div class="powerup-item">
              <span style="font-size: 24px;">üî´</span>
              <p><strong>Laser Weapon</strong><br>Powerful beam weapon</p>
            </div>
            <div class="powerup-item">
              <span style="font-size: 24px;">üõ°Ô∏è</span>
              <p><strong>Shield</strong><br>Temporary invincibility</p>
            </div>
            <div class="powerup-item">
              <span style="font-size: 24px;">‚ô•Ô∏è</span>
              <p><strong>City Repair</strong><br>Restore city health</p>
            </div>
            <div class="powerup-item">
              <span style="font-size: 24px;">‚ö°</span>
              <p><strong>Electric Hose</strong><br>Handle electrical fires</p>
            </div>
            <div class="powerup-item">
              <span style="font-size: 24px;">üíù</span>
              <p><strong>Life Repair</strong><br>Restore ship health</p>
            </div>
            <div class="powerup-item">
              <span style="font-size: 24px;">üí£</span>
              <p><strong>Bomb</strong><br>Clear all visible fires</p>
            </div>
            <div class="powerup-item">
              <span style="font-size: 24px;">üåü</span>
              <p><strong>Life Shield</strong><br>Extra life + protection</p>
            </div>
          </div>
        </div>

        <!-- Store Upgrades Section -->
        <div class="section" id="storeUpgrades">
          <h2>üí∞ Store Upgrades</h2>
          <p style="font-size: 1.2em; margin-bottom: 15px;">Your Currency: <span id="currencyDisplay">0</span></p>
          
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
            <div class="store-item">
              <h4>üíß Hose Upgrade</h4>
              <p>Status: <span id="hoseUpgradeDisplay">Tier 0 / 5</span></p>
              <p>Cost: <span id="hoseUpgradeCostDisplay">500</span></p>
              <button id="upgradeHoseBtn" class="ascii-button">Purchase Hose Upgrade</button>
            </div>

            <div class="store-item">
              <h4>üöÄ Base Speed Upgrade</h4>
              <p>Status: <span id="speedUpgradeDisplay">Tier 0 / 5</span></p>
              <p>Cost: <span id="speedUpgradeCostDisplay">1000</span></p>
              <button id="upgradeSpeedBtn" class="ascii-button">Purchase Speed Upgrade</button>
            </div>

            <div class="store-item">
              <h4>üé® Unlock Ship Color</h4>
              <p>Cost: <span id="shipColorUnlockCostDisplay">1000</span></p>
              <button id="unlockShipColorBtn" class="ascii-button">Unlock Ship Color</button>
            </div>

            <div class="store-item">
              <h4>‚ú® Unlock Trail Color</h4>
              <p>Cost: <span id="trailColorUnlockCostDisplay">1000</span></p>
              <button id="unlockTrailColorBtn" class="ascii-button">Unlock Trail Color</button>
            </div>

            <div class="store-item">
              <h4>üåà Multi‚ÄëColor Trail</h4>
              <p>Status: <span id="multiColorDisplay">Locked</span></p>
              <p>Cost: <span id="multiColorCostDisplay">2000</span></p>
              <button id="upgradeMultiColorBtn" class="ascii-button">Unlock Multi‚ÄëColor</button>
            </div>

            <div class="store-item">
              <h4>üíù Heart Spawn Rate</h4>
              <p>Current: <span id="heartChanceDisplay">10%</span></p>
              <p>Cost: <span id="heartChanceCostDisplay">1500</span></p>
              <button id="upgradeHeartChanceBtn" class="ascii-button">Upgrade Heart Rate</button>
            </div>

            <div class="store-item">
              <h4>üéµ Background Music 2</h4>
              <p>Status: <span id="background2Display">Locked</span></p>
              <p>Cost: <span id="background2CostDisplay">1500</span></p>
              <button id="unlockBackground2Btn" class="ascii-button">Unlock Background 2</button>
            </div>

            <div class="store-item">
              <h4>‚ù§Ô∏è Base Health</h4>
              <p>Status: <span id="baseHealthUpgradeDisplay">Tier 0 / 3</span></p>
              <p>Cost: <span id="baseHealthUpgradeCostDisplay">1000</span></p>
              <button id="upgradeBaseHealthBtn" class="ascii-button">Purchase Health Upgrade</button>
            </div>

            <div class="store-item">
              <h4>üì¶ Pickup Size</h4>
              <p>Status: <span id="pickupSizeUpgradeDisplay">Tier 0 / 2</span></p>
              <p>Cost: <span id="pickupSizeUpgradeCostDisplay">1500</span></p>
              <button id="upgradePickupSizeBtn" class="ascii-button">Purchase Size Upgrade</button>
            </div>

            <div class="store-item">
              <h4>‚è±Ô∏è Powerup Duration</h4>
              <p>Status: <span id="powerupDurationUpgradeDisplay">Tier 0 / 3</span></p>
              <p>Cost: <span id="powerupDurationUpgradeCostDisplay">2000</span></p>
              <button id="upgradePowerupDurationBtn" class="ascii-button">Purchase Duration Upgrade</button>
            </div>
          </div>
        </div>

        <!-- Color Selection Section -->
        <div class="section" id="colorSelection">
          <h2>üé® Customization</h2>
          <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 5px;">
            <h3>Ship Colors</h3>
            <p id="shipColorLabel">Ship Color: <span id="currentShipColor">Default (#0066cc)</span></p>
            <div id="shipColorOptions"></div>
            <h3>Trail Colors</h3>
            <p id="currentTrailColorLabel">Trail Color: <span id="currentTrailColor">Default (#00ffff)</span></p>
            <div id="trailColorOptions"></div>
            <p>(Unlock additional colors in the store.)</p>
          </div>
        </div>

        <!-- Background Music Selection Section -->
        <div class="section" id="bgMusicSelection" style="margin-top: 20px;">
          <h4>üéµ Background Music</h4>
          <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px;">
            <div style="margin-bottom: 10px;">
              <label style="margin-right: 15px;"><input type="radio" name="bgMusic" value="default" checked /> Track 1</label>
              <label style="margin-right: 15px;"><input type="radio" name="bgMusic" value="background2" /> Track 2</label>
              <label><input type="radio" name="bgMusic" value="custom" /> Custom Track</label>
            </div>
            <div id="localTrackContainer" style="margin-top: 10px; display: none;">
              <label for="localTrackInput">Select MP3 File: </label>
              <input type="file" id="localTrackInput" accept="audio/*" style="margin-top: 5px;" />
            </div>
          </div>
        </div>

        <button id="startBtn" class="ascii-button" style="font-size: 24px; margin-top: 30px; padding: 15px 40px;">
          üöÄ Start Mission
        </button>
      </div>
    </div>

    <!-- Notification Container -->
    <div id="notificationContainer" class="notification"></div>

    <!-- Credit Link -->
    <a href="https://sonnycirasuolo.com" target="_blank" id="creditLink"
      >sonnycirasuolo.com</a
    >

    <!-- Canvas -->
    <canvas id="gameCanvas"></canvas>

    <script>
      window.addEventListener("load", () => {
        if (!backgroundMusic) {
          initAudio();
        }
      });
      // ===============================
      // ASCII Art Definitions
      // ===============================
      function drawAsciiArt(art, x, y, fontSize, color) {
        ctx.font = `${fontSize}px monospace`;
        ctx.fillStyle = color;
        const lineHeight = fontSize * 1.2;
        for (let i = 0; i < art.length; i++) {
          ctx.fillText(art[i], x, y + i * lineHeight);
        }
      }
      const rotatedPlayerArt = ["   __  ", "  /  ) ", " |[] | ", "  \\__)"];
      const normalFireArt = ["  FFF  ", " FFFFF ", "  FFF  "];
      const electricalFireArt = ["  EEE  ", " EEEEE ", "  EEE  "];
      const mineArt = ["  /M\\  ", " | M | ", "  \\M/  "];
      const debrisArt = ["  ___  ", " / D \\ ", " \\___/ "];

      const playerFontSize = 20;
      const fireFontSize = 18;
      const obstacleFontSize = 18;
      const powerupFontSize = 20;

      // Global shield rotation for animated shield effect.
      let shieldRotation = 0;

      // ===============================
      // GLOBAL SETTINGS & PERSISTENCE
      // ===============================
      const asciiMode = true;

      // Global color variables - move to top with other globals
      let playerColor = "#0066cc";  // Default ship color
      let selectedTrailColor = "#00ffff";  // Default trail color

      // Expanded color options
      let defaultShipColors = [
        "#0066cc",
        "#ff0000",
        "#00ff00",
        "#ffff00",
        "#ff00ff",
        "#00ffcc",
        "#ff6600",
        "#6600ff",
        "#ff9933",
        "#33cc33",
      ];
      let defaultTrailColors = [
        "#00ffff",
        "#ff00ff",
        "#ffff00",
        "#ff9900",
        "#99ff00",
        "#ff6699",
        "#6699ff",
        "#33cc33",
        "#cc33ff",
        "#33ffcc",
      ];

      // Merge defaults into storeData
      const defaultStoreData = {
        currency: 0,
        hoseTier: 0,
        speedTier: 0,
        baseHealthTier: 0,
        pickupSizeTier: 0,
        powerupDurationTier: 0,
        unlockedShipColors: ["#0066cc"],
        unlockedTrailColors: ["#00ffff"],
        selectedShipColor: "#0066cc",
        selectedTrailColor: "#00ffff",
        multiColorTrailUnlocked: false,
        heartSpawnChance: 0.2,
        highScore: 0,
        background2Unlocked: false,
      };
      let storedData = localStorage.getItem("storeData");
      let storeData = storedData ? JSON.parse(storedData) : {};
      storeData = Object.assign({}, defaultStoreData, storeData);

      // Update color values from stored data
      playerColor = storeData.selectedShipColor;
      selectedTrailColor = storeData.selectedTrailColor;

      function saveStoreData() {
        localStorage.setItem("storeData", JSON.stringify(storeData));
      }

      // ===============================
      // UI HELPER FUNCTIONS
      // ===============================
      function updateColorOptionsUI() {
        const shipDiv = document.getElementById("shipColorOptions");
        const trailDiv = document.getElementById("trailColorOptions");
        
        // Update the current color displays
        document.getElementById("currentShipColor").textContent = storeData.selectedShipColor;
        document.getElementById("currentTrailColor").textContent = 
          storeData.selectedTrailColor === "multicolor" ? "Multi‚ÄëColor" : storeData.selectedTrailColor;

        shipDiv.innerHTML = "";
        defaultShipColors.forEach((color) => {
          let btn = document.createElement("button");
          btn.className = "color-option ship-color";
          btn.style.background = color;
          btn.setAttribute("data-color", color);
          if (storeData.unlockedShipColors.includes(color)) {
            if (color === storeData.selectedShipColor) {
              btn.classList.add("selected");
            }
            btn.addEventListener("click", () => {
              document
                .querySelectorAll(".ship-color")
                .forEach((b) => b.classList.remove("selected"));
              btn.classList.add("selected");
              playerColor = color;
              storeData.selectedShipColor = color;
              saveStoreData();
              document.getElementById("currentShipColor").textContent = color;
            });
          } else {
            btn.classList.add("disabled");
            btn.title = "Locked: Unlock in store";
          }
          shipDiv.appendChild(btn);
        });

        trailDiv.innerHTML = "";
        defaultTrailColors.forEach((color) => {
          let btn = document.createElement("button");
          btn.className = "color-option trail-color";
          btn.style.background = color;
          btn.setAttribute("data-color", color);
          if (storeData.unlockedTrailColors.includes(color)) {
            if (color === storeData.selectedTrailColor) {
              btn.classList.add("selected");
            }
            btn.addEventListener("click", () => {
              document
                .querySelectorAll(".trail-color")
                .forEach((b) => b.classList.remove("selected"));
              btn.classList.add("selected");
              selectedTrailColor = color;
              storeData.selectedTrailColor = color;
              saveStoreData();
              document.getElementById("currentTrailColor").textContent = color;
            });
          } else {
            btn.classList.add("disabled");
            btn.title = "Locked: Unlock in store";
          }
          trailDiv.appendChild(btn);
        });

        // Add multicolor button
        let multiBtn = document.createElement("button");
        multiBtn.className = "color-option trail-color";
        multiBtn.style.backgroundImage =
          "linear-gradient(to right, red, yellow, green, cyan, blue, magenta)";
        multiBtn.setAttribute("data-color", "multicolor");
        multiBtn.textContent = "MC";
        if (storeData.multiColorTrailUnlocked) {
          if (storeData.selectedTrailColor === "multicolor") {
            multiBtn.classList.add("selected");
          }
          multiBtn.addEventListener("click", () => {
            document
              .querySelectorAll(".trail-color")
              .forEach((b) => b.classList.remove("selected"));
            multiBtn.classList.add("selected");
            selectedTrailColor = "multicolor";
            storeData.selectedTrailColor = "multicolor";
            saveStoreData();
            document.getElementById("currentTrailColor").textContent = "Multi‚ÄëColor";
          });
        } else {
          multiBtn.classList.add("disabled");
          multiBtn.title = "Locked: Unlock in store";
        }
        trailDiv.appendChild(multiBtn);

        // Make sure the initial trail color is set correctly
        selectedTrailColor = storeData.selectedTrailColor;
      }

      function updateStoreUI() {
        // Add null checks for all DOM elements
        const currencyDisplay = document.getElementById("currencyDisplay");
        const hoseUpgradeDisplay = document.getElementById("hoseUpgradeDisplay");
        const hoseUpgradeCostDisplay = document.getElementById("hoseUpgradeCostDisplay");
        const speedUpgradeDisplay = document.getElementById("speedUpgradeDisplay");
        const speedUpgradeCostDisplay = document.getElementById("speedUpgradeCostDisplay");
        const multiColorDisplay = document.getElementById("multiColorDisplay");
        const multiColorCostDisplay = document.getElementById("multiColorCostDisplay");
        const heartChanceDisplay = document.getElementById("heartChanceDisplay");
        const heartChanceCostDisplay = document.getElementById("heartChanceCostDisplay");
        const background2Display = document.getElementById("background2Display");
        const background2CostDisplay = document.getElementById("background2CostDisplay");
        const baseHealthUpgradeDisplay = document.getElementById("baseHealthUpgradeDisplay");
        const baseHealthUpgradeCostDisplay = document.getElementById("baseHealthUpgradeCostDisplay");
        const pickupSizeUpgradeDisplay = document.getElementById("pickupSizeUpgradeDisplay");
        const pickupSizeUpgradeCostDisplay = document.getElementById("pickupSizeUpgradeCostDisplay");
        const powerupDurationUpgradeDisplay = document.getElementById("powerupDurationUpgradeDisplay");
        const powerupDurationUpgradeCostDisplay = document.getElementById("powerupDurationUpgradeCostDisplay");
        
        // Get all button references
        const upgradeHoseBtn = document.getElementById("upgradeHoseBtn");
        const upgradeSpeedBtn = document.getElementById("upgradeSpeedBtn");
        const upgradeMultiColorBtn = document.getElementById("upgradeMultiColorBtn");
        const unlockBackground2Btn = document.getElementById("unlockBackground2Btn");
        const unlockShipColorBtn = document.getElementById("unlockShipColorBtn");
        const unlockTrailColorBtn = document.getElementById("unlockTrailColorBtn");
        const upgradeHeartChanceBtn = document.getElementById("upgradeHeartChanceBtn");
        const upgradeBaseHealthBtn = document.getElementById("upgradeBaseHealthBtn");
        const upgradePickupSizeBtn = document.getElementById("upgradePickupSizeBtn");
        const upgradePowerupDurationBtn = document.getElementById("upgradePowerupDurationBtn");
        const bgMusic2Label = document.getElementById("bgMusic2Label");

        if (currencyDisplay) currencyDisplay.textContent = storeData.currency;
        
        // Hose upgrade
        if (storeData.hoseTier < 5) {
          if (hoseUpgradeDisplay) hoseUpgradeDisplay.textContent = "Tier " + storeData.hoseTier + " / 5";
          if (hoseUpgradeCostDisplay) hoseUpgradeCostDisplay.textContent = 500 * Math.pow(2, storeData.hoseTier);
          if (upgradeHoseBtn) upgradeHoseBtn.style.display = "inline-block";
        } else {
          if (hoseUpgradeDisplay) hoseUpgradeDisplay.textContent = "Maxed (Tier 5)";
          if (hoseUpgradeCostDisplay) hoseUpgradeCostDisplay.textContent = "N/A";
          if (upgradeHoseBtn) upgradeHoseBtn.style.display = "none";
        }

        // Speed upgrade
        if (storeData.speedTier < 5) {
          if (speedUpgradeDisplay) speedUpgradeDisplay.textContent = "Tier " + storeData.speedTier + " / 5";
          if (speedUpgradeCostDisplay) speedUpgradeCostDisplay.textContent = 1000 * Math.pow(2, storeData.speedTier);
          if (upgradeSpeedBtn) upgradeSpeedBtn.style.display = "inline-block";
        } else {
          if (speedUpgradeDisplay) speedUpgradeDisplay.textContent = "Maxed (Tier 5)";
          if (speedUpgradeCostDisplay) speedUpgradeCostDisplay.textContent = "N/A";
          if (upgradeSpeedBtn) upgradeSpeedBtn.style.display = "none";
        }

        // Base Health upgrade
        if (storeData.baseHealthTier < 3) {
          if (baseHealthUpgradeDisplay) baseHealthUpgradeDisplay.textContent = "Tier " + storeData.baseHealthTier + " / 3";
          if (baseHealthUpgradeCostDisplay) baseHealthUpgradeCostDisplay.textContent = 1000 * Math.pow(2, storeData.baseHealthTier);
          if (upgradeBaseHealthBtn) upgradeBaseHealthBtn.style.display = "inline-block";
        } else {
          if (baseHealthUpgradeDisplay) baseHealthUpgradeDisplay.textContent = "Maxed (Tier 3)";
          if (baseHealthUpgradeCostDisplay) baseHealthUpgradeCostDisplay.textContent = "N/A";
          if (upgradeBaseHealthBtn) upgradeBaseHealthBtn.style.display = "none";
        }

        // Pickup Size upgrade
        if (storeData.pickupSizeTier < 2) {
          if (pickupSizeUpgradeDisplay) pickupSizeUpgradeDisplay.textContent = "Tier " + storeData.pickupSizeTier + " / 2";
          if (pickupSizeUpgradeCostDisplay) pickupSizeUpgradeCostDisplay.textContent = 1500 * Math.pow(2, storeData.pickupSizeTier);
          if (upgradePickupSizeBtn) upgradePickupSizeBtn.style.display = "inline-block";
        } else {
          if (pickupSizeUpgradeDisplay) pickupSizeUpgradeDisplay.textContent = "Maxed (Tier 2)";
          if (pickupSizeUpgradeCostDisplay) pickupSizeUpgradeCostDisplay.textContent = "N/A";
          if (upgradePickupSizeBtn) upgradePickupSizeBtn.style.display = "none";
        }

        // Powerup Duration upgrade
        if (storeData.powerupDurationTier < 3) {
          if (powerupDurationUpgradeDisplay) powerupDurationUpgradeDisplay.textContent = "Tier " + storeData.powerupDurationTier + " / 3";
          if (powerupDurationUpgradeCostDisplay) powerupDurationUpgradeCostDisplay.textContent = 2000 * Math.pow(2, storeData.powerupDurationTier);
          if (upgradePowerupDurationBtn) upgradePowerupDurationBtn.style.display = "inline-block";
        } else {
          if (powerupDurationUpgradeDisplay) powerupDurationUpgradeDisplay.textContent = "Maxed (Tier 3)";
          if (powerupDurationUpgradeCostDisplay) powerupDurationUpgradeCostDisplay.textContent = "N/A";
          if (upgradePowerupDurationBtn) upgradePowerupDurationBtn.style.display = "none";
        }

        // Multi-color trail
        if (multiColorDisplay) multiColorDisplay.textContent = storeData.multiColorTrailUnlocked ? "Unlocked" : "Locked";
        if (multiColorCostDisplay) multiColorCostDisplay.textContent = 2000;
        if (upgradeMultiColorBtn) upgradeMultiColorBtn.style.display = storeData.multiColorTrailUnlocked ? "none" : "inline-block";

        // Heart chance
        if (heartChanceDisplay) heartChanceDisplay.textContent = Math.floor(storeData.heartSpawnChance * 100) + "%";
        if (heartChanceCostDisplay) heartChanceCostDisplay.textContent = 1500;
        if (upgradeHeartChanceBtn) upgradeHeartChanceBtn.style.display = storeData.heartSpawnChance >= 1.0 ? "none" : "inline-block";

        // Background music 2
        if (background2Display) background2Display.textContent = storeData.background2Unlocked ? "Unlocked" : "Locked";
        if (background2CostDisplay) background2CostDisplay.textContent = 1500;
        if (unlockBackground2Btn) unlockBackground2Btn.style.display = storeData.background2Unlocked ? "none" : "inline-block";

        // Ship colors
        const unlockedAllShipColors = defaultShipColors.every(color => storeData.unlockedShipColors.includes(color));
        if (unlockShipColorBtn) unlockShipColorBtn.style.display = unlockedAllShipColors ? "none" : "inline-block";

        // Trail colors
        const unlockedAllTrailColors = defaultTrailColors.every(color => storeData.unlockedTrailColors.includes(color));
        if (unlockTrailColorBtn) unlockTrailColorBtn.style.display = unlockedAllTrailColors ? "none" : "inline-block";

        // Update high score display
        const highScoreDisplay = document.getElementById("highScoreDisplay");
        if (highScoreDisplay) highScoreDisplay.textContent = storeData.highScore;

        // Show/hide background music 2 radio button based on unlock status
        if (bgMusic2Label) {
          bgMusic2Label.style.display = storeData.background2Unlocked ? "inline" : "none";
        }
      }

      // Move the music selection section to after powerup duration upgrade
      const musicSection = document.getElementById("bgMusicSelection");
      const localTrackContainer = document.getElementById("localTrackContainer");
      const powerupDurationSection = document.querySelector('.store-item:has(#powerupDurationUpgradeDisplay)');
      
      if (musicSection && powerupDurationSection) {
        // Remove the music sections from their current position
        musicSection.parentNode.removeChild(musicSection);
        localTrackContainer.parentNode.removeChild(localTrackContainer);
        
        // Insert them after the powerup duration section
        powerupDurationSection.insertAdjacentElement('afterend', musicSection);
        musicSection.insertAdjacentElement('afterend', localTrackContainer);
      }

      // ===============================
      // CANVAS & GAME SETUP
      // ===============================
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      ctx.textBaseline = "top";

      const scoreEl = document.getElementById("score");
      const comboEl = document.getElementById("combo");
      const powerupTimersEl = document.getElementById("powerupTimers");
      const cityHealthEl = document.getElementById("cityHealth");
      const shipHealthEl = document.getElementById("shipHealth");
      const gameOverEl = document.getElementById("gameOver");
      const gameOverText = document.getElementById("gameOverText");
      const restartBtn = document.getElementById("restartBtn");
      const tutorialEl = document.getElementById("tutorial");
      const startBtn = document.getElementById("startBtn");
      const notificationContainer = document.getElementById(
        "notificationContainer"
      );
      const boostTimerUI = document.getElementById("boostTimerUI");

      const currencyDisplay = document.getElementById("currencyDisplay");
      const hoseUpgradeDisplay = document.getElementById("hoseUpgradeDisplay");
      const hoseUpgradeCostDisplay = document.getElementById(
        "hoseUpgradeCostDisplay"
      );
      const speedUpgradeDisplay = document.getElementById(
        "speedUpgradeDisplay"
      );
      const speedUpgradeCostDisplay = document.getElementById(
        "speedUpgradeCostDisplay"
      );
      const multiColorDisplay = document.getElementById("multiColorDisplay");
      const multiColorCostDisplay = document.getElementById(
        "multiColorCostDisplay"
      );
      const heartChanceDisplay = document.getElementById("heartChanceDisplay");
      const heartChanceCostDisplay = document.getElementById(
        "heartChanceCostDisplay"
      );
      const background2Display = document.getElementById("background2Display");
      const background2CostDisplay = document.getElementById(
        "background2CostDisplay"
      );

      const cityHealthBar = document.getElementById("cityHealthBar");

      // Audio Setup (lazy initialization to avoid autoplay issues)
      let backgroundMusic,
        waterSplashSound,
        laserSound,
        explosionSound,
        powerupSound,
        extinguishSound,
        fireWhooshSound;
      let audioCtx, analyser;
      function initAudio() {
        if (!backgroundMusic) {
          try {
            backgroundMusic = new Audio("sounds/background.mp3");
            backgroundMusic.loop = true;
            backgroundMusic.volume = 0.5;
            waterSplashSound = new Audio("sounds/water-splash.mp3");
            laserSound = new Audio("sounds/laser.mp3");
            explosionSound = new Audio("sounds/explosion.mp3");
            powerupSound = new Audio("sounds/powerup.mp3");
            extinguishSound = new Audio("sounds/extinguish.mp3");
            fireWhooshSound = new Audio("sounds/fire-whoosh.mp3");
            fireWhooshSound.loop = false;

            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 256;
            const sourceNode = audioCtx.createMediaElementSource(backgroundMusic);
            sourceNode.connect(analyser);
            analyser.connect(audioCtx.destination);
          } catch (e) {
            console.log("Web Audio API not supported or initialization failed:", e);
          }
        }
      }

      // ===============================
      // GAME VARIABLES & TIMERS
      // ===============================
      // Level progression variables
      let score = 0;  // Overall score
      let currentLevelScore = 0;  // Score for current level only
      let comboCount = 0;
      let comboTimer = 0;
      const comboResetTime = 2000;
      let gameSpeed = 1;
      let gameOver = false;
      let lastTime = 0;
      let bubbleTimer = 0;
      let bubbleInterval = 1000;
      let obstacleTimer = 0;
      let obstacleInterval = 3000;
      let boostTimer = 7000;
      let boostInterval = 7000;
      let laserActive = false;

      // Define different score thresholds for each level
      const LEVEL_SCORE_THRESHOLDS = {
        1: 1000,  // Level 1 needs 1000 points
        2: 2000,  // Level 2 needs 2000 points
        3: 3000   // Level 3 needs 3000 points
      };

      // Define base speeds for each level
      const LEVEL_SPEEDS = {
        1: 1.0,    // Base speed
        2: 1.5,    // 50% faster
        3: 2.0     // 100% faster
      };

      let currentLevel = 1;
      const MAX_LEVELS = 3;
      let player = null;
      let notifications = [];
      let isPaused = false;
      let levelTransitionActive = false;
      let bossSpawned = false;
      const keys = {};

      // Mobile control variables
      let mobileJoystickActive = false,
        mobileDx = 0,
        mobileDy = 0;
      let mobileFireActive = false;
      let lastMobileFireTime = 0;
      const fireInterval = 300;
      let movementStartX, movementStartY;
      let movementTouchId = null,
        fireTouchId = null;

      if ("ontouchstart" in window) {
        canvas.addEventListener("touchstart", handleTouchStart, false);
        canvas.addEventListener("touchmove", handleTouchMove, false);
        canvas.addEventListener("touchend", handleTouchEnd, false);
      }

      function handleTouchStart(e) {
        e.preventDefault();
        for (let i = 0; i < e.changedTouches.length; i++) {
          let touch = e.changedTouches[i];
          if (
            touch.clientX < window.innerWidth / 2 &&
            movementTouchId === null
          ) {
            movementTouchId = touch.identifier;
            mobileJoystickActive = true;
            movementStartX = touch.clientX;
            movementStartY = touch.clientY;
            mobileDx = 0;
            mobileDy = 0;
          } else if (
            touch.clientX >= window.innerWidth / 2 &&
            fireTouchId === null
          ) {
            fireTouchId = touch.identifier;
            mobileFireActive = true;
          }
        }
      }

      function handleTouchMove(e) {
        e.preventDefault();
        for (let i = 0; i < e.changedTouches.length; i++) {
          let touch = e.changedTouches[i];
          if (touch.identifier === movementTouchId) {
            let dx = touch.clientX - movementStartX;
            let dy = touch.clientY - movementStartY;
            const maxDelta = 50;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const ratio = Math.min(distance / maxDelta, 1);
            const angle = Math.atan2(dy, dx);
            mobileDx = Math.cos(angle) * (player ? player.speed : 5) * ratio;
            mobileDy = Math.sin(angle) * (player ? player.speed : 5) * ratio;
          }
        }
      }

      function handleTouchEnd(e) {
        e.preventDefault();
        for (let i = 0; i < e.changedTouches.length; i++) {
          let touch = e.changedTouches[i];
          if (touch.identifier === movementTouchId) {
            movementTouchId = null;
            mobileJoystickActive = false;
            mobileDx = 0;
            mobileDy = 0;
            movementStartX = undefined;
            movementStartY = undefined;
          }
          if (touch.identifier === fireTouchId) {
            fireTouchId = null;
            mobileFireActive = false;
          }
        }
      }

      window.addEventListener("resize", () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        updateAsciiCityPattern();
      });

      // ===============================
      // SCORE POPUP CLASS
      // ===============================
      let scorePopups = [];
      class ScorePopup {
        constructor(x, y, points) {
          this.x = x;
          this.y = y;
          this.points = points;
          this.timer = 1000;
          this.opacity = 1;
        }
        update(deltaTime) {
          this.y -= 0.5;
          this.timer -= deltaTime;
          this.opacity = Math.max(this.timer / 1000, 0);
        }
        draw() {
          ctx.font = "16px monospace";
          ctx.fillStyle = `rgba(255,255,255,${this.opacity})`;
          ctx.fillText("+" + this.points, this.x, this.y);
        }
      }

      // ===============================
      // CLASS DEFINITIONS
      // ===============================
      class Background {
        constructor() {
          this.x = 0;
          this.y = 0;
          this.width = canvas.width;
          this.height = canvas.height;
          this.speed = gameSpeed / 2;
        }
        draw() {
          if (asciiMode) {
            ctx.fillStyle = "#001224";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
          }
        }
        update() {
          this.x -= this.speed;
          if (this.x <= -this.width) this.x = 0;
          this.draw();
        }
      }

      // -------------------
      // Create the city BEFORE the player.
      // -------------------
      class City {
        constructor() {
          this.width = 300; // The vertical boundary of the city
          this.health = 100;
          this.maxHealth = 100;
          this.hitTimer = 0;
          this.exploded = false;
        }
        hit(damage) {
          this.health -= damage;
          if (this.health < 0) this.health = 0;
          this.hitTimer = 300;
        }
        update(deltaTime) {
          if (this.hitTimer > 0) this.hitTimer -= deltaTime;
        }
        draw() {
          /* Drawn separately */
        }
      }

      let city = new City();

      class Player {
        constructor() {
          this.x = Math.max(150, city.width);
          this.y = canvas.height / 2 - 48;
          this.baseSpeed = 5 + storeData.speedTier;
          this.speed = this.baseSpeed;
          this.dx = 0;
          this.dy = 0;
          this.boostTime = 0;
          this.hoseUpgradeTime = 0;
          this.laserWeaponTime = 0;
          this.invisibilityTime = 0;
          this.shieldTime = 0;
          this.electricHoseTime = 0;
          this.lifeShieldActive = false;  // New property for life shield
          this.artWidth = 96;
          this.artHeight = 96;
          this.lives = 3 + storeData.baseHealthTier; // Base health affected by upgrade
          this.maxLives = 3 + storeData.baseHealthTier;
          this.baseMovementSpeed = 4;
          this.movementSpeed = this.baseMovementSpeed * (1 + storeData.speedTier * 0.1);
        }
        draw() {
          if (asciiMode) {
            spawnPlayerTrail(this.x, this.y, this.artWidth, this.artHeight);
            drawAsciiArt(rotatedPlayerArt, this.x, this.y, playerFontSize, playerColor);
            
            // Draw regular shield if active
            if (this.shieldTime > 0) {
              let centerX = this.x + this.artWidth / 2;
              let centerY = this.y + this.artHeight / 2;
              let shieldRadius = this.artWidth;
              let numStars = 12;
              for (let i = 0; i < numStars; i++) {
                let angle = shieldRotation + (i * 2 * Math.PI) / numStars;
                let starX = centerX + shieldRadius * Math.cos(angle);
                let starY = centerY + shieldRadius * Math.sin(angle);
                ctx.font = "16px monospace";
                ctx.fillStyle = "#00ffff";
                ctx.fillText("*", starX, starY);
              }
            }
            
            // Draw life shield if active (different visual effect)
            if (this.lifeShieldActive) {
              let centerX = this.x + this.artWidth / 2;
              let centerY = this.y + this.artHeight / 2;
              let shieldRadius = this.artWidth * 1.2;
              let numHearts = 8;
              for (let i = 0; i < numHearts; i++) {
                let angle = shieldRotation + (i * 2 * Math.PI) / numHearts;
                let heartX = centerX + shieldRadius * Math.cos(angle);
                let heartY = centerY + shieldRadius * Math.sin(angle);
                ctx.font = "16px monospace";
                ctx.fillStyle = "#ff69b4";
                ctx.fillText("‚ô•", heartX, heartY);
              }
            }
          }
        }
        update(deltaTime) {
          if (this.boostTime > 0) {
            this.boostTime -= deltaTime;
            if (this.boostTime <= 0) {
              this.boostTime = 0;
              this.speed = this.baseSpeed;
            }
          }
          if (this.hoseUpgradeTime > 0) this.hoseUpgradeTime -= deltaTime;
          if (this.laserWeaponTime > 0) this.laserWeaponTime -= deltaTime;
          if (this.invisibilityTime > 0) this.invisibilityTime -= deltaTime;
          if (this.shieldTime > 0) this.shieldTime -= deltaTime;
          if (this.electricHoseTime > 0) this.electricHoseTime -= deltaTime;
          this.x += this.dx;
          this.y += this.dy;
          // Prevent ship from going above or below canvas
          if (this.y < 0) this.y = 0;
          if (this.y + this.artHeight > canvas.height)
            this.y = canvas.height - this.artHeight;
          // Prevent ship from going past the right edge of canvas
          if (this.x + this.artWidth > canvas.width)
            this.x = canvas.width - this.artWidth;
          // Prevent ship from going past the city line (left boundary)
          if (this.x < city.width) this.x = city.width;
          this.draw();
        }
        center() {
          return {
            cx: this.x + this.artWidth / 2,
            cy: this.y + this.artHeight / 2,
          };
        }
      }


      class WaterProjectile {
        constructor(x, y, enhanced = false) {
          this.x = x;
          this.y = y;
          this.enhanced = enhanced;
          this.speed = enhanced ? 12 : 8;
        }
        draw() {
          ctx.font = "16px monospace";
          // Change color based on electric hose instead of enhanced status
          if (player.electricHoseTime > 0) {
            ctx.fillStyle = "#66ccff"; // Electric blue for electric hose
          } else {
            ctx.fillStyle = "#0066ff"; // Regular blue for normal water
          }
          ctx.fillText("~", this.x, this.y);
        }
        update() {
          this.x += this.speed;
          this.draw();
        }
      }

      class FireBubble {
        constructor(type = "normal") {
          this.type = type;
          this.x = canvas.width + 20;
          // Add 50px margin at top and bottom
          const minY = 50;
          const maxY = canvas.height - 110; // 60px original margin + 50px extra
          this.y = minY + Math.random() * (maxY - minY);
          this.speed = gameSpeed + Math.random() * 2;
        }
        draw() {
          if (asciiMode) {
            const art =
              this.type === "electrical" ? electricalFireArt : normalFireArt;
            const color = this.type === "electrical" ? "#66ccff" : "#ff3300";
            drawAsciiArt(art, this.x, this.y, fireFontSize, color);
          }
        }
        update() {
          this.x -= this.speed;
          this.draw();
        }
      }

      class Obstacle {
        constructor() {
          this.x = canvas.width + 40;
          this.y = Math.random() * (canvas.height - 60);
          this.speed = gameSpeed + Math.random() * 1.5;
          this.type = Math.random() < 0.5 ? "mine" : "debris";
        }
        draw() {
          if (asciiMode) {
            let art = this.type === "mine" ? mineArt : debrisArt;
            drawAsciiArt(art, this.x, this.y, obstacleFontSize, "#ffffff");
          }
        }
        update() {
          this.x -= this.speed;
          this.draw();
        }
      }

      // All pickup icons drawn at 2x their original size:
      function drawRotatingGlowingText(ctx, text, x, y, font, baseColor, rotation) {
        // Scale font size based on pickup size tier
        const pickupSizes = [20, 30, 40]; // Base size increases with tier
        const fontSize = pickupSizes[storeData.pickupSizeTier || 0];
        const pulse = 10 + 5 * Math.abs(Math.sin(Date.now() / 200));
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);
        ctx.font = `${fontSize}px monospace`;
        ctx.fillStyle = baseColor;
        ctx.shadowColor = baseColor;
        ctx.shadowBlur = pulse;
        ctx.fillText(text, 0, 0);
        ctx.restore();
      }

      class BoostPickup {
        constructor() {
          this.x = canvas.width + 30;
          this.y = Math.random() * (canvas.height - 30);
          this.speed = gameSpeed;
          this.rotation = 0;
        }
        update(deltaTime) {
          this.x -= this.speed;
          this.rotation += deltaTime * 0.005;
          this.draw();
        }
        draw() {
          drawRotatingGlowingText(ctx, "üöÄ", this.x, this.y, "20px monospace", "#ffcc00", this.rotation);
        }
      }
      class HoseUpgradePickup {
        constructor() {
          this.x = canvas.width + 30;
          this.y = Math.random() * (canvas.height - 30);
          this.speed = gameSpeed;
          this.rotation = 0;
        }
        update(deltaTime) {
          this.x -= this.speed;
          this.rotation += deltaTime * 0.005;
          this.draw();
        }
        draw() {
          drawRotatingGlowingText(ctx, "üíß", this.x, this.y, "20px monospace", "#00ff00", this.rotation);
        }
      }
      class LaserWeaponPickup {
        constructor() {
          this.x = canvas.width + 30;
          this.y = Math.random() * (canvas.height - 30);
          this.speed = gameSpeed;
          this.rotation = 0;
        }
        update(deltaTime) {
          this.x -= this.speed;
          this.rotation += deltaTime * 0.005;
          this.draw();
        }
        draw() {
          drawRotatingGlowingText(ctx, "üî´", this.x, this.y, "20px monospace", "#66ccff", this.rotation);
        }
      }
      class ShieldPickup {
        constructor() {
          this.x = canvas.width + 30;
          this.y = Math.random() * (canvas.height - 30);
          this.speed = gameSpeed;
          this.rotation = 0;
        }
        update(deltaTime) {
          this.x -= this.speed;
          this.rotation += deltaTime * 0.005;
          this.draw();
        }
        draw() {
          drawRotatingGlowingText(ctx, "üõ°Ô∏è", this.x, this.y, "20px monospace", "#ff66cc", this.rotation);
        }
      }
      class CityHealthPickup {
        constructor() {
          this.x = canvas.width + 30;
          this.y = Math.random() * (canvas.height - 30);
          this.speed = gameSpeed;
          this.rotation = 0; // initialize rotation
        }
        update(deltaTime) {
          this.x -= this.speed;
          this.rotation += deltaTime * 0.005; // update rotation
          this.draw();
        }
        draw() {
          // Draw "‚ô•" with rotation and pulsing glow.
          drawRotatingGlowingText(ctx, "‚ô•", this.x, this.y, "20px monospace", "#ff0000", this.rotation);
        }
      }
      class ElectricHosePickup {
        constructor() {
          this.x = canvas.width + 30;
          this.y = Math.random() * (canvas.height - 30);
          this.speed = gameSpeed;
          this.rotation = 0;
        }
        update(deltaTime) {
          this.x -= this.speed;
          this.rotation += deltaTime * 0.005;
          this.draw();
        }
        draw() {
          drawRotatingGlowingText(ctx, "‚ö°", this.x, this.y, "20px monospace", "#ffff00", this.rotation);
        }
      }

      // New electric sound for electrical fires
      const electricSound = new Audio("sounds/electric.mp3");

      // Modify powerup font sizes in ASCII Art
      const boostFontSize = 10; // Half original size
      const heartAndElectricFontSize = 40; // Double original size

 

      // Boss definitions
      const bosses = {
        1: {
          art: [
            "   ‚ïî‚ïê‚ïê‚ïê‚ïó   ",
            "   ‚ïëB-1‚ïë   ",
            " ‚ïî‚ïê‚ïù‚ñà‚ñà‚ñà‚ïö‚ïê‚ïó ",
            " ‚ïö‚ïê[===]‚ïê‚ïù "
          ],
          health: 100,
          pattern: "linear"
        },
        2: {
          art: [
            " ‚ïî‚ïê‚ïó ‚ïî‚ïê‚ïó ",
            " ‚ïëB‚ïë~‚ïë2‚ïë ",
            "‚ïî‚ïù‚ñà‚ïö‚ïê‚ïù‚ñà‚ïö‚ïó",
            "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
          ],
          health: 150,
          pattern: "sine"
        },
        3: {
          art: [
            "  ‚ñÑ‚ñà‚ñà‚ñà‚ñÑ  ",
            "‚ïî‚ïê‚ïë-B3-‚ïë‚ïê‚ïó",
            "‚ïö‚ïê‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïê‚ïù",
            " ‚ñÄ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÄ "
          ],
          health: 200,
          pattern: "spiral"
        }
      };

      // New powerup: Bomb
      class BombPickup {
        constructor() {
          this.x = canvas.width + 30;
          this.y = Math.random() * (canvas.height - 30);
          this.speed = gameSpeed;
          this.rotation = 0;
        }
        update(deltaTime) {
          this.x -= this.speed;
          this.rotation += deltaTime * 0.005;
          this.draw();
        }
        draw() {
          drawRotatingGlowingText(ctx, "üí£", this.x, this.y, "20px monospace", "#ff0000", this.rotation);
        }
        activate() {
          // Clear all fire bubbles with explosion effect
          fireBubbles.forEach(fire => {
            spawnParticles(fire.x, fire.y, "255,0,0", 20);
            addScore(10);  // Use addScore instead of direct score modification
            storeData.currency += 5;
          });
          fireBubbles = [];
          addNotification("üí£ BOOM! All fires cleared!");
          explosionSound.currentTime = 0;
          explosionSound.play();
        }
      }

      // New powerup: Life Shield
      class LifeShieldPickup {
        constructor() {
          this.x = canvas.width + 30;
          this.y = Math.random() * (canvas.height - 30);
          this.speed = gameSpeed;
          this.rotation = 0;
        }
        update(deltaTime) {
          this.x -= this.speed;
          this.rotation += deltaTime * 0.005;
          this.draw();
        }
        draw() {
          drawRotatingGlowingText(ctx, "üåü", this.x, this.y, "20px monospace", "#ffd700", this.rotation);
        }
      }

      // Level completion modal
      function showLevelModal(level) {
        // Remove any existing level modals to prevent duplicates
        document.querySelectorAll('.level-modal').forEach(modal => modal.remove());
        isPaused = true;
        levelTransitionActive = true;
        
        const modal = document.createElement('div');
        modal.className = 'level-modal';
        
        let content = '';
        if (level === 2) {
          content = `
            <h2>Level 2 Unlocked!</h2>
            <p>New Features:<br>
            - Rotating fire patterns<br>
            - Bomb powerup (üí£) clears all visible fires<br>
            - Increased difficulty</p>
          `;
        } else if (level === 3) {
          content = `
            <h2>Level 3 Unlocked!</h2>
            <p>New Features:<br>
            - Complex fire movement patterns<br>
            - Life Shield powerup (üåü) restores ship health<br>
            - Maximum difficulty</p>
          `;
        }

        modal.innerHTML = `
          ${content}
          <button onclick="resumeAfterLevelTransition(this)">Continue</button>
        `;

        document.body.appendChild(modal);
      }

      // Add this new function to handle level transition resume
      function resumeAfterLevelTransition(buttonElement) {
        isPaused = false;
        levelTransitionActive = false;
        buttonElement.parentElement.remove();
      }

      // Modify UI to show level progress
      const levelDisplay = document.createElement('div');
      levelDisplay.style.cssText = `
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        color: #fff;
        font-family: monospace;
        font-size: 20px;
        z-index: 10;
      `;
      document.body.appendChild(levelDisplay);

      let boostPickups = [];
      let hoseUpgrades = [];
      let laserPickups = [];
      let shieldPickups = [];
      let cityHealthPickups = [];
      let electricHosePickups = [];
      let bombPickups = [];
      let lifeShieldPickups = [];
      let playerHealthPickups = []; // New array

      let waterProjectiles = [];
      let fireBubbles = [];
      let obstacles = [];
      let particles = [];
      class Particle {
        constructor(x, y, color) {
          this.x = x;
          this.y = y;
          this.speed = Math.random() * 2 + 1;
          this.angle = Math.random() * Math.PI * 2;
          this.life = 200;
          this.opacity = 1;
          this.color = color;
        }
        update(deltaTime) {
          this.x += Math.cos(this.angle) * this.speed;
          this.y += Math.sin(this.angle) * this.speed;
          this.life -= deltaTime * 0.1;
          this.opacity = this.life / 200;
        }
        draw() {
          ctx.font = "12px monospace";
          ctx.fillStyle = `rgba(${this.color}, ${this.opacity})`;
          ctx.fillText("*", this.x, this.y);
        }
      }

      function hexToRgbString(hex) {
        hex = hex.replace(/^#/, "");
        if (hex.length === 3) {
          hex = hex
            .split("")
            .map((c) => c + c)
            .join("");
        }
        const bigint = parseInt(hex, 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;
        return r + "," + g + "," + b;
      }

      function spawnPlayerTrail(x, y, artWidth, artHeight) {
        const trailX = x - 10;
        const trailY = y + artHeight / 2;
        const numParticles = 3;
        for (let i = 0; i < numParticles; i++) {
          let col;
          if (player.boostTime > 0) {
            col = "#ffcc00";
          } else {
            if (selectedTrailColor === "random") {
              col = "#00ffff";
            } else if (selectedTrailColor === "multicolor") {
              const colors = [
                "#ff0000",
                "#ffff00",
                "#00ff00",
                "#00ffff",
                "#0000ff",
                "#ff00ff",
              ];
              col = colors[Math.floor(Math.random() * colors.length)];
            } else {
              col = selectedTrailColor;
            }
          }
          let p = new Particle(trailX, trailY, hexToRgbString(col));
          p.angle = Math.PI + (Math.random() * 0.1 - 0.05);
          particles.push(p);
        }
      }

      function spawnParticles(x, y, color, count) {
        for (let i = 0; i < count * 2; i++) {
          particles.push(new Particle(x, y, color));
        }
      }

      // ===============================
      // ASCII BUBBLE CLASS (for decorative bubbles)
      // ===============================
      let asciiBubbles = [];
      let asciiBubbleTimer = 0;
      const asciiBubbleInterval = 1000; // 3x as frequent
      class AsciiBubble {
        constructor() {
          this.x = Math.random() * canvas.width;
          this.y = canvas.height + 20;
          this.speed = 0.5 + Math.random() * 1.0;
          const symbols = ["o", "O", "¬∞"];
          this.symbol = symbols[Math.floor(Math.random() * symbols.length)];
          this.opacity = 1;
        }
        update(deltaTime) {
          this.y -= this.speed * (deltaTime / 16);
          this.opacity = Math.max(this.y / canvas.height, 0);
        }
        draw() {
          ctx.font = "16px monospace";
          ctx.fillStyle = `rgba(173,216,230,${(this.opacity * 0.7).toFixed(
            2
          )})`;
          ctx.fillText(this.symbol, this.x, this.y);
        }
      }

      // ===============================
      // Global Game Objects
      // ===============================
      let background = new Background();
      // 'city' was already created above.
      // 'player' was created after city.

      // ===============================
      // ASCII City Silhouette (Centered vertically)
      // ===============================
      let asciiCityPattern = [];
      const asciiCityFontSize = 12;
      const asciiCityCharWidth = 8;

      // Regenerate skyline based on half the canvas height.
      function updateAsciiCityPattern() {
        const areaWidth = city.width;
        const skylineHeight = canvas.height * 0.5; // half the canvas height
        const rows = Math.floor(skylineHeight / asciiCityFontSize);
        const cols = Math.floor(areaWidth / asciiCityCharWidth);
        let buildingHeights = [];
        let buildingChars = [];
        for (let i = 0; i < cols; i++) {
          if (Math.random() < 0.1) {
            buildingHeights[i] = 0;
            buildingChars[i] = " ";
          } else {
            buildingHeights[i] = Math.floor(
              Math.random() * (rows - Math.floor(0.5 * rows)) +
                Math.floor(0.5 * rows)
            );
            const chars = ["‚ñà", "‚ñì", "‚ñí", "‚ñë"];
            buildingChars[i] = chars[Math.floor(Math.random() * chars.length)];
          }
        }
        let pattern = [];
        for (let r = 0; r < rows; r++) {
          let rowStr = "";
          for (let c = 0; c < cols; c++) {
            if (r >= rows - buildingHeights[c]) {
              rowStr += buildingChars[c];
            } else {
              rowStr += " ";
            }
          }
          pattern.push(rowStr);
        }
        asciiCityPattern = pattern;
      }

      function drawAsciiCity() {
        // Draw full vertical boundary line (from top to bottom)
        ctx.beginPath();
        ctx.moveTo(city.width, 0);
        ctx.lineTo(city.width, canvas.height);
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.stroke();

        // Draw left side city background (full height)
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, city.width, canvas.height);

        // Center the skyline vertically
        const skylineHeight = canvas.height * 0.5;
        const startY = canvas.height / 2 - skylineHeight / 2;
        ctx.font = `${asciiCityFontSize}px monospace`;

        // Flash red when hit
        let buildingColor = "rgba(34,34,34,0.8)";
        if (city.hitTimer > 0) {
          buildingColor = "red";
        }
        ctx.fillStyle = buildingColor;

        const cols = asciiCityPattern[0] ? asciiCityPattern[0].length : 0;
        const xOffset = (city.width - cols * asciiCityCharWidth) / 2;
        for (let i = 0; i < asciiCityPattern.length; i++) {
          let row = asciiCityPattern[i];
          // Add flickering window lights: randomly replace some building blocks with "o"
          let modifiedRow = "";
          for (let ch of row) {
            if (ch !== " " && Math.random() < 0.3) {
              modifiedRow += "o";
            } else {
              modifiedRow += ch;
            }
          }
          const y = startY + i * asciiCityFontSize;
          ctx.fillText(modifiedRow, xOffset, y);
        }
      }

      setInterval(updateAsciiCityPattern, 1000);
      updateAsciiCityPattern();

      // ===============================
      // INPUT HANDLING
      // ===============================
      document.addEventListener("keydown", (e) => {
        keys[e.key] = true;
        if (e.key === " ") {
          if (player.laserWeaponTime > 0) {
            laserActive = true;
          } else {
            const center = player.center();
            if (player.hoseUpgradeTime > 0) {
              let baseCount =
                storeData.hoseTier > 0 ? 1 + 2 * storeData.hoseTier : 1;
              let count = baseCount * 2;
              let spacing = 10;
              let startOffset = -Math.floor(count / 2) * spacing;
              for (let i = 0; i < count; i++) {
                waterProjectiles.push(
                  new WaterProjectile(
                    center.cx,
                    center.cy + startOffset + i * spacing,
                    true
                  )
                );
              }
            } else if (storeData.hoseTier > 0) {
              let count = 1 + 2 * storeData.hoseTier;
              let spacing = 10;
              let startOffset = -Math.floor(count / 2) * spacing;
              for (let i = 0; i < count; i++) {
                waterProjectiles.push(
                  new WaterProjectile(
                    center.cx,
                    center.cy + startOffset + i * spacing,
                    false
                  )
                );
              }
            } else {
              waterProjectiles.push(
                new WaterProjectile(center.cx, center.cy, false)
              );
            }
            waterSplashSound.currentTime = 0;
            waterSplashSound.play();
          }
        }
      });
      document.addEventListener("keyup", (e) => {
        keys[e.key] = false;
        if (e.key === " ") {
          laserActive = false;
        }
      });

      function circleCollision(c1, c2) {
        const r1 = c1.radius !== undefined ? c1.radius : 20;
        const r2 = c2.radius !== undefined ? c2.radius : 20;
        const dx = c1.x - c2.x,
          dy = c1.y - c2.y;
        return Math.sqrt(dx * dx + dy * dy) < r1 + r2;
      }
      function rectCollision(r1, r2) {
        if (player.invisibilityTime > 0) return false;
        const pickupSizes = [30, 45, 60]; // Size increases with tier
        const pickupSize = pickupSizes[storeData.pickupSizeTier];
        return (
          r1.x < r2.x + pickupSize &&
          r1.x + player.artWidth > r2.x &&
          r1.y < r2.y + pickupSize &&
          r1.y + player.artHeight > r2.y
        );
      }

      function addNotification(message) {
        // Replace text descriptions with emojis in notifications
        message = message.replace("Speed Boost", "üöÄ Speed Boost")
          .replace("Hose Upgrade", "üíß Hose Upgrade")
          .replace("Laser Weapon", "üî´ Laser Weapon")
          .replace("Shield", "üõ°Ô∏è Shield")
          .replace("Electric Hose", "‚ö° Electric Hose")
          .replace("City Repaired", "‚ô•Ô∏è City Repaired");
        
        notifications.push({ message: message, timer: 2000 });
        if (message.includes("Acquired")) {
          powerupSound.currentTime = 0;
          powerupSound.play();
        }
      }
      function updateNotifications(deltaTime) {
        notificationContainer.innerHTML = "";
        notifications.forEach((note) => {
          note.timer -= deltaTime;
          const opacity = Math.max(note.timer / 2000, 0);
          const div = document.createElement("div");
          div.style.opacity = opacity;
          div.textContent = note.message;
          notificationContainer.appendChild(div);
        });
        notifications = notifications.filter((note) => note.timer > 0);
      }

      // ===============================
      // Music Visualizer (as Bubbles)
      // ===============================
      // Global bubble array
      let bubbles = [];

      // Call this function in your animation loop
      // Global array for the arch bubbles ‚Äì place this at the top of your script.
      let archBubbles = [];

      // New audio visualizer function that creates an arch of "0" characters.
      function drawMusicVisualizerBubbles() {
        if (!analyser) return;
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        analyser.getByteFrequencyData(dataArray);

        const bottomMargin = 30;
        const maxArchHeight = 200;
        const bubbleFadeRate = 0.002;
        const spawnProbability = 0.03;

        for (let i = 0; i < bufferLength; i++) {
          if (Math.random() > spawnProbability) continue;
          const amplitude = dataArray[i];
          const x = i * (canvas.width / bufferLength);
          const y =
            canvas.height - bottomMargin - (amplitude / 255) * maxArchHeight;
          const fontSize = 10 + (amplitude / 255) * 20;
          const vy = Math.random() * 0.3 + 0.1;
          archBubbles.push({
            x: x,
            y: y,
            fontSize: fontSize,
            vy: vy,
            opacity: 1.0,
          });
        }

        for (let i = archBubbles.length - 1; i >= 0; i--) {
          const bubble = archBubbles[i];
          bubble.y -= bubble.vy;
          bubble.opacity -= bubbleFadeRate;

          if (bubble.opacity <= 0 || bubble.y < 0) {
            archBubbles.splice(i, 1);
            continue;
          }
          ctx.font = `${bubble.fontSize}px monospace`;
          // Increase transparency by 50%
          ctx.fillStyle = `rgba(255,255,255,${(bubble.opacity * 0.5).toFixed(
            2
          )})`;
          ctx.fillText("0", bubble.x, bubble.y);
        }
      }

      // ===============================
      // MAIN GAME LOOP
      // ===============================
      let animationId;
      function animate(timestamp) {
        const deltaTime = timestamp - lastTime;
        lastTime = timestamp;
        shieldRotation += deltaTime * 0.005;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        background.speed = gameSpeed / 2;
        background.update();

        drawMusicVisualizerBubbles();
        drawAsciiCity();
        city.update(deltaTime);

        // Always update and draw the level display
        levelDisplay.textContent = `Level: ${currentLevel}/${MAX_LEVELS}`;

        if (!gameOver && !isPaused) {
          const levelThreshold = LEVEL_SCORE_THRESHOLDS[currentLevel] || 1000;
          // Update level display to show progress towards boss
          levelDisplay.textContent = `Level: ${currentLevel}/${MAX_LEVELS} (${currentLevelScore}/${levelThreshold} to boss)`;
          
          // Handle boss battle - add null check before accessing properties
          if (currentBoss && currentBoss.isActive) {
            currentBoss.update(deltaTime);
            currentBoss.draw();

            // Check for water projectile hits on boss
            for (let i = waterProjectiles.length - 1; i >= 0; i--) {
              let proj = waterProjectiles[i];
              if (currentBoss && // Add additional null check
                  proj.x >= currentBoss.x && 
                  proj.x <= currentBoss.x + 100 && 
                  proj.y >= currentBoss.y && 
                  proj.y <= currentBoss.y + 80) {
                currentBoss.hit(proj.enhanced ? 2 : 1);
                spawnParticles(proj.x, proj.y, "255,255,255", 5);
                waterProjectiles.splice(i, 1);
              }
            }

            // Check for laser hits on boss
            if (laserActive && player.laserWeaponTime > 0 && currentBoss) { // Add null check
              const center = player.center();
              if (center.cy >= currentBoss.y && center.cy <= currentBoss.y + 80) {
                currentBoss.hit(0.5);
                spawnParticles(currentBoss.x, center.cy, "255,0,0", 2);
              }
            }
          }

          // Adjust difficulty based on level
          const baseSpeed = LEVEL_SPEEDS[currentLevel] || 1.0;
          gameSpeed = baseSpeed + (currentLevelScore / levelThreshold * 0.5); // Gradual speed increase within level
          gameSpeed = Math.min(gameSpeed, baseSpeed * 1.5); // Cap at 50% above base speed

          // Update intervals based on level speed
          bubbleInterval = Math.max(300, 1000 / baseSpeed);
          obstacleInterval = Math.max(1000, 3000 / baseSpeed);

          let targetDx = 0,
            targetDy = 0;
          if (keys["ArrowLeft"] || keys["a"]) targetDx = -player.movementSpeed;
          if (keys["ArrowRight"] || keys["d"]) targetDx = player.movementSpeed;
          if (keys["ArrowUp"] || keys["w"]) targetDy = -player.movementSpeed;
          if (keys["ArrowDown"] || keys["s"]) targetDy = player.movementSpeed;
          if (mobileJoystickActive) {
            targetDx = mobileDx;
            targetDy = mobileDy;
          }
          player.dx += (targetDx - player.dx) * 0.2;
          player.dy += (targetDy - player.dy) * 0.2;
          player.update(deltaTime);

          if ("ontouchstart" in window) {
            if (mobileFireActive) {
              if (player.laserWeaponTime > 0) {
                laserActive = true;
              } else {
                if (timestamp - lastMobileFireTime > fireInterval) {
                  let center = player.center();
                  if (player.hoseUpgradeTime > 0) {
                    let baseCount =
                      storeData.hoseTier > 0 ? 1 + 2 * storeData.hoseTier : 1;
                    let count = baseCount * 2;
                    let spacing = 10;
                    let startOffset = -Math.floor(count / 2) * spacing;
                    for (let i = 0; i < count; i++) {
                      waterProjectiles.push(
                        new WaterProjectile(
                          center.cx,
                          center.cy + startOffset + i * spacing,
                          true
                        )
                      );
                    }
                  } else if (storeData.hoseTier > 0) {
                    let count = 1 + 2 * storeData.hoseTier;
                    let spacing = 10;
                    let startOffset = -Math.floor(count / 2) * spacing;
                    for (let i = 0; i < count; i++) {
                      waterProjectiles.push(
                        new WaterProjectile(
                          center.cx,
                          center.cy + startOffset + i * spacing,
                          false
                        )
                      );
                    }
                  } else {
                    waterProjectiles.push(
                      new WaterProjectile(center.cx, center.cy, false)
                    );
                  }
                  waterSplashSound.currentTime = 0;
                  waterSplashSound.play();
                  lastMobileFireTime = timestamp;
                }
              }
            } else {
              laserActive = false;
            }
          }

          if (laserActive && player.laserWeaponTime > 0) {
            const center = player.center();
            ctx.font = "16px monospace";
            ctx.fillStyle = "#ff0000";
            const beamLength = canvas.width - center.cx;
            const numChars = Math.floor(beamLength / 10);
            const beamText = "=".repeat(numChars);
            ctx.fillText(beamText, center.cx, center.cy - 8);
            for (let j = fireBubbles.length - 1; j >= 0; j--) {
              let fire = fireBubbles[j];
              if (fire.type === "electrical") continue;
              if (
                fire.x > center.cx &&
                fire.x < canvas.width &&
                Math.abs(fire.y - center.cy) < 20
              ) {
                extinguishSound.currentTime = 0;
                extinguishSound.play();
                spawnParticles(fire.x, fire.y, "255,150,0", 30);
                scorePopups.push(
                  new ScorePopup(fire.x, fire.y, 5 * (comboCount || 1))
                );
                fireBubbles.splice(j, 1);
                comboCount = comboTimer > 0 ? comboCount + 1 : 1;
                comboTimer = comboResetTime;
                addScore(5 * comboCount);  // Use addScore instead of direct score modification
                storeData.currency += 10;
                saveStoreData();
              }
            }
            if (laserSound.paused) {
              laserSound.loop = true;
              laserSound.play();
            }
          } else {
            if (!laserSound.paused) {
              laserSound.pause();
              laserSound.currentTime = 0;
            }
          }

          for (let i = waterProjectiles.length - 1; i >= 0; i--) {
            let proj = waterProjectiles[i];
            proj.update();
            if (proj.x > canvas.width) {
              waterProjectiles.splice(i, 1);
              continue;
            }
            for (let j = fireBubbles.length - 1; j >= 0; j--) {
              let fire = fireBubbles[j];
              if (fire.type === "electrical" && player.electricHoseTime <= 0)
                continue;
              if (circleCollision(proj, fire)) {
                if (fire.type === "electrical") {
                  electricSound.currentTime = 0;
                  electricSound.play();
                } else {
                  extinguishSound.currentTime = 0;
                  extinguishSound.play();
                }
                spawnParticles(fire.x, fire.y, "255,150,0", 30);
                scorePopups.push(
                  new ScorePopup(fire.x, fire.y, 5 * (comboCount || 1))
                );
                fireBubbles.splice(j, 1);
                comboCount = comboTimer > 0 ? comboCount + 1 : 1;
                comboTimer = comboResetTime;
                addScore(5 * comboCount);  // Use addScore instead of direct score modification
                storeData.currency += 10;
                saveStoreData();
                break;
              }
            }
          }
          if (comboTimer > 0) {
            comboTimer -= deltaTime;
          } else {
            comboCount = 0;
          }
          comboEl.textContent = comboCount + "x";

          bubbleTimer += deltaTime;
          if (bubbleTimer > bubbleInterval) {
            let type = Math.random() < 0.2 ? "electrical" : "normal";
            fireBubbles.push(new FireBubble(type));
            bubbleTimer = 0;
            bubbleInterval = Math.max(300, bubbleInterval - 20);
            gameSpeed += 0.05;
          }
          for (let i = fireBubbles.length - 1; i >= 0; i--) {
            let fire = fireBubbles[i];
            fire.speed = gameSpeed + Math.random() * 2;
            fire.update();
            if (fire.type === "electrical") {
              if (rectCollision(player, fire)) {
                spawnParticles(fire.x, fire.y, "0,255,255", 40);
                scorePopups.push(new ScorePopup(fire.x, fire.y, 10));
                fireBubbles.splice(i, 1);
                addScore(10);  // Use addScore instead of direct score modification
                storeData.currency += 10;
                electricSound.currentTime = 0;
                electricSound.play();
                addNotification("Electrical fire extinguished!");
                continue;
              }
            }
            if (fire.x < city.width) {
              // Fire reached the city
              city.hit(fire.type === "electrical" ? 15 : 10);
              fireWhooshSound.currentTime = 0;
              fireWhooshSound.play();
              fireBubbles.splice(i, 1);
            } else if (fire.x < 0) {
              fireBubbles.splice(i, 1);
            }
          }

          obstacleTimer += deltaTime;
          if (obstacleTimer > obstacleInterval) {
            obstacles.push(new Obstacle());
            obstacleTimer = 0;
            obstacleInterval = Math.max(1000, obstacleInterval - 30);
          }
          for (let i = obstacles.length - 1; i >= 0; i--) {
            let obs = obstacles[i];
            obs.speed = gameSpeed + Math.random() * 1.5;
            obs.update();
            if (rectCollision(player, obs)) {
              if (player.shieldTime > 0) {
                player.shieldTime = 0;
                addNotification("Shield absorbed the hit!");
                obstacles.splice(i, 1);
              } else if (player.lifeShieldActive) {
                player.lifeShieldActive = false;
                addNotification("Life Shield protected you!");
                obstacles.splice(i, 1);
              } else {
                player.lives--;
                let center = player.center();
                if (player.lives > 0) {
                  spawnParticles(center.cx, center.cy, "255,0,0", 30);
                } else {
                  spawnParticles(center.cx, center.cy, "255,0,0", 50);
                  spawnParticles(center.cx, center.cy, "255,150,0", 50);
                  spawnParticles(center.cx, center.cy, "255,255,0", 50);
                }
                explosionSound.currentTime = 0;
                explosionSound.play();
                addNotification("Hit! Lives left: " + player.lives);
                obstacles.splice(i, 1);
                if (player.lives <= 0) {
                  gameOver = true;
                }
              }
            } else if (obs.x < 0) {
              obstacles.splice(i, 1);
            }
          }

          boostTimer += deltaTime;
          if (boostTimer > boostInterval) {
            let rnd = Math.random();
            
            // First, check for heart spawns with a higher base chance (30%)
            if (rnd < 0.3) {
              // Heart pickup spawn logic with upgraded chance and guaranteed minimum
              if (Math.random() < Math.max(storeData.heartSpawnChance, 0.2)) {
                // Alternate between city and player health pickups with 50/50 chance
                if (Math.random() < 0.5) {
                  cityHealthPickups.push(new CityHealthPickup());
                } else {
                  playerHealthPickups.push(new PlayerHealthPickup());
                }
              }
            }
            // Then distribute other powerups in remaining 70%
            else {
              rnd = (rnd - 0.3) / 0.7; // Normalize remaining probability space
              if (rnd < 0.2) {
                boostPickups.push(new BoostPickup());
              } else if (rnd < 0.4) {
                hoseUpgrades.push(new HoseUpgradePickup());
              } else if (rnd < 0.6) {
                laserPickups.push(new LaserWeaponPickup());
              } else if (rnd < 0.7) {
                shieldPickups.push(new ShieldPickup());
              } else if (rnd < 0.8) {
                electricHosePickups.push(new ElectricHosePickup());
              } else if (rnd < 0.9) {
                if (currentLevel >= 2) {
                  bombPickups.push(new BombPickup());
                }
              } else {
                if (currentLevel >= 3) {
                  lifeShieldPickups.push(new LifeShieldPickup());
                }
              }
            }
            boostTimer = 0;
          }
          for (let i = boostPickups.length - 1; i >= 0; i--) {
            let boost = boostPickups[i];
            boost.update(deltaTime);
            if (rectCollision(player, boost)) {
              player.boostTime = getPowerupDuration();
              player.speed = player.baseSpeed * 1.5;
              boostPickups.splice(i, 1);
              addNotification("Speed Boost Acquired!");
            } else if (boost.x < 0) {
              boostPickups.splice(i, 1);
            }
          }
          for (let i = hoseUpgrades.length - 1; i >= 0; i--) {
            let pickup = hoseUpgrades[i];
            pickup.update(deltaTime);
            if (rectCollision(player, pickup)) {
              player.hoseUpgradeTime = getPowerupDuration();
              hoseUpgrades.splice(i, 1);
              addNotification("Hose Upgrade Acquired!");
            } else if (pickup.x < 0) {
              hoseUpgrades.splice(i, 1);
            }
          }
          for (let i = laserPickups.length - 1; i >= 0; i--) {
            let pickup = laserPickups[i];
            pickup.update(deltaTime);
            if (rectCollision(player, pickup)) {
              player.laserWeaponTime = getPowerupDuration();
              laserPickups.splice(i, 1);
              addNotification("Laser Weapon Acquired!");
            } else if (pickup.x < 0) {
              laserPickups.splice(i, 1);
            }
          }
          for (let i = shieldPickups.length - 1; i >= 0; i--) {
            let pickup = shieldPickups[i];
            pickup.update(deltaTime);
            if (rectCollision(player, pickup)) {
              player.shieldTime = getPowerupDuration();
              shieldPickups.splice(i, 1);
              addNotification("Shield Acquired!");
            } else if (pickup.x < 0) {
              shieldPickups.splice(i, 1);
            }
          }
          for (let i = electricHosePickups.length - 1; i >= 0; i--) {
            let pickup = electricHosePickups[i];
            pickup.update(deltaTime);
            if (rectCollision(player, pickup)) {
              player.electricHoseTime = getPowerupDuration();
              electricHosePickups.splice(i, 1);
              addNotification("Electric Hose Acquired!");
            } else if (pickup.x < 0) {
              electricHosePickups.splice(i, 1);
            }
          }
          for (let i = cityHealthPickups.length - 1; i >= 0; i--) {
            let pickup = cityHealthPickups[i];
            pickup.update(deltaTime);
            if (rectCollision(player, pickup)) {
              // Only collect if city health is not full
              if (city.health < city.maxHealth) {
                city.health = Math.min(city.maxHealth, city.health + 20);
                addNotification("City Repaired! üè∞");
                spawnParticles(100, canvas.height / 2, "0,255,0", 200);
                addScore(50);  // Add points for repairing the city
                storeData.currency += 50;
                saveStoreData();
              } else {
                addNotification("City health already full!");
              }
              cityHealthPickups.splice(i, 1);
            } else if (pickup.x < 0) {
              cityHealthPickups.splice(i, 1);
            }
          }
          for (let i = lifeShieldPickups.length - 1; i >= 0; i--) {
            let pickup = lifeShieldPickups[i];
            pickup.update(deltaTime);
            if (rectCollision(player, pickup)) {
              player.lifeShieldActive = true;
              player.lives = Math.min(player.lives + 1, 5); // Increase lives up to max of 5
              lifeShieldPickups.splice(i, 1);
              addNotification("Life Shield Acquired! +1 Life!");
              spawnParticles(player.x, player.y, "255,105,180", 50); // Pink particles
            } else if (pickup.x < 0) {
              lifeShieldPickups.splice(i, 1);
            }
          }
          for (let i = playerHealthPickups.length - 1; i >= 0; i--) {
            let pickup = playerHealthPickups[i];
            pickup.update(deltaTime);
            if (rectCollision(player, pickup)) {
              // Only collect if health is not full
              if (player.lives < player.maxLives) {
                player.lives = Math.min(player.lives + 1, player.maxLives);
                addNotification("Extra Life Acquired! üíù");
                spawnParticles(player.x, player.y, "255,20,147", 50); // Deep pink particles
              } else {
                addNotification("Health already full!");
              }
              playerHealthPickups.splice(i, 1);
            } else if (pickup.x < 0) {
              playerHealthPickups.splice(i, 1);
            }
          }

          // Add bomb pickup collision check
          for (let i = bombPickups.length - 1; i >= 0; i--) {
            let pickup = bombPickups[i];
            pickup.update(deltaTime);
            if (rectCollision(player, pickup)) {
              pickup.activate();
              bombPickups.splice(i, 1);
              spawnParticles(player.x, player.y, "255,0,0", 100);
            } else if (pickup.x < 0) {
              bombPickups.splice(i, 1);
            }
          }
        }

        for (let i = scorePopups.length - 1; i >= 0; i--) {
          scorePopups[i].update(deltaTime);
          scorePopups[i].draw();
          if (scorePopups[i].timer <= 0) {
            scorePopups.splice(i, 1);
          }
        }

        for (let i = particles.length - 1; i >= 0; i--) {
          particles[i].update(deltaTime);
          particles[i].draw();
          if (particles[i].life <= 0) {
            particles.splice(i, 1);
          }
        }
        updateNotifications(deltaTime);

        powerupTimersEl.textContent =
          (player.boostTime > 0
            ? "üöÄ: " + (player.boostTime / 1000).toFixed(1) + "s "
            : "") +
          (player.hoseUpgradeTime > 0
            ? "üíß: " + (player.hoseUpgradeTime / 1000).toFixed(1) + "s "
            : "") +
          (player.laserWeaponTime > 0
            ? "üî´: " + (player.laserWeaponTime / 1000).toFixed(1) + "s "
            : "") +
          (player.shieldTime > 0
            ? "üõ°Ô∏è: " + (player.shieldTime / 1000).toFixed(1) + "s "
            : "") +
          (player.electricHoseTime > 0
            ? "‚ö°: " + (player.electricHoseTime / 1000).toFixed(1) + "s"
            : "");

        cityHealthEl.textContent = city.health + "/" + city.maxHealth;
        shipHealthEl.textContent = player.lives + "/" + player.maxLives;

        let healthRatio = city.health / city.maxHealth;
        cityHealthBar.style.width = healthRatio * 100 + "%";
        if (healthRatio > 0.66) cityHealthBar.style.background = "green";
        else if (healthRatio > 0.33) cityHealthBar.style.background = "yellow";
        else cityHealthBar.style.background = "red";

        if (city.health <= 0) {
          gameOver = true;
          backgroundMusic.pause();
          gameOverText.textContent = "Game Over! Final Score: " + score;
        }
        scoreEl.textContent = score;
        gameOverEl.style.display = gameOver ? "block" : "none";

        if (gameOver && score > storeData.highScore) {
          storeData.highScore = score;
          saveStoreData();
          updateStoreUI();
        }
        document.getElementById("highScoreDisplay").textContent =
          storeData.highScore;

        asciiBubbleTimer += deltaTime;
        if (asciiBubbleTimer > asciiBubbleInterval) {
          asciiBubbles.push(new AsciiBubble());
          asciiBubbleTimer = 0;
        }
        for (let i = asciiBubbles.length - 1; i >= 0; i--) {
          asciiBubbles[i].update(deltaTime);
          asciiBubbles[i].draw();
          if (asciiBubbles[i].y < -20) {
            asciiBubbles.splice(i, 1);
          }
        }

        // Update the top-right Upgrade Timer UI with all active upgrades
        let timersText = "";
        if (player.boostTime > 0)
          timersText += "üöÄ: " + (player.boostTime / 1000).toFixed(1) + "s ";
        if (player.hoseUpgradeTime > 0)
          timersText += "üíß: " + (player.hoseUpgradeTime / 1000).toFixed(1) + "s ";
        if (player.laserWeaponTime > 0)
          timersText += "üî´: " + (player.laserWeaponTime / 1000).toFixed(1) + "s ";
        if (player.shieldTime > 0)
          timersText += "üõ°Ô∏è: " + (player.shieldTime / 1000).toFixed(1) + "s ";
        if (player.electricHoseTime > 0)
          timersText += "‚ö°: " + (player.electricHoseTime / 1000).toFixed(1) + "s ";
        boostTimerUI.textContent = "Upgrades: " + (timersText || "None");

        animationId = requestAnimationFrame(animate);
      }

      updateColorOptionsUI();

      document
        .getElementById("upgradeHoseBtn")
        .addEventListener("click", () => {
          if (storeData.hoseTier < 5) {
            let cost = 500 * Math.pow(2, storeData.hoseTier);
            if (storeData.currency >= cost) {
              storeData.currency -= cost;
              storeData.hoseTier++;
              saveStoreData();
              updateStoreUI();
              addNotification(
                "Hose Upgrade Tier " + storeData.hoseTier + " Purchased!"
              );
            } else {
              alert("Not enough currency!");
            }
          } else {
            alert("Hose is fully upgraded!");
          }
        });

      document
        .getElementById("upgradeSpeedBtn")
        .addEventListener("click", () => {
          if (storeData.speedTier < 5) {
            let cost = 1000 * Math.pow(2, storeData.speedTier);
            if (storeData.currency >= cost) {
              storeData.currency -= cost;
              storeData.speedTier++;
              // Update only the player's movement speed without affecting gameSpeed.
              player.movementSpeed =
                player.baseMovementSpeed * (1 + storeData.speedTier * 0.1);
              saveStoreData();
              updateStoreUI();
              addNotification(
                "Speed Upgrade Tier " + storeData.speedTier + " Purchased!"
              );
            } else {
              alert("Not enough currency!");
            }
          } else {
            alert("Speed is fully upgraded!");
          }
        });

      document
        .getElementById("unlockShipColorBtn")
        .addEventListener("click", () => {
          const cost = 1000;
          if (storeData.currency < cost) {
            alert("Not enough currency to unlock a ship color!");
            return;
          }
          let lockedShip = defaultShipColors.filter(
            (c) => !storeData.unlockedShipColors.includes(c)
          );
          if (lockedShip.length > 0) {
            let unlockColor = lockedShip[0];
            storeData.currency -= cost;
            storeData.unlockedShipColors.push(unlockColor);
            addNotification("Unlocked ship color: " + unlockColor);
            saveStoreData();
            updateStoreUI();
            updateColorOptionsUI();
          } else {
            alert("All ship colors unlocked!");
          }
        });

      document
        .getElementById("unlockTrailColorBtn")
        .addEventListener("click", () => {
          const cost = 1000;
          if (storeData.currency < cost) {
            alert("Not enough currency to unlock a trail color!");
            return;
          }
          let lockedTrail = defaultTrailColors.filter(
            (c) => !storeData.unlockedTrailColors.includes(c)
          );
          if (lockedTrail.length > 0) {
            let unlockColor = lockedTrail[0];
            storeData.currency -= cost;
            storeData.unlockedTrailColors.push(unlockColor);
            addNotification("Unlocked trail color: " + unlockColor);
            saveStoreData();
            updateStoreUI();
            updateColorOptionsUI();
          } else {
            alert("All trail colors unlocked!");
          }
        });

      document
        .getElementById("upgradeMultiColorBtn")
        .addEventListener("click", () => {
          if (
            !storeData.multiColorTrailUnlocked &&
            storeData.currency >= 2000
          ) {
            storeData.currency -= 2000;
            storeData.multiColorTrailUnlocked = true;
            saveStoreData();
            updateStoreUI();
            updateColorOptionsUI();
            addNotification("Multi‚ÄëColor Trail Unlocked!");
          } else {
            alert("Not enough currency or already unlocked!");
          }
        });

      document
        .getElementById("upgradeHeartChanceBtn")
        .addEventListener("click", () => {
          if (storeData.currency >= 1500) {
            storeData.currency -= 1500;
            // Cap at 100%
            storeData.heartSpawnChance = Math.min(storeData.heartSpawnChance + 0.05, 1.0);
            saveStoreData();
            updateStoreUI();
            addNotification("Heart Spawn Rate Upgraded!");
          } else {
            alert("Not enough currency for Heart Spawn Rate upgrade!");
          }
        });

      document
        .getElementById("unlockBackground2Btn")
        .addEventListener("click", () => {
          if (!storeData.background2Unlocked && storeData.currency >= 1500) {
            storeData.currency -= 1500;
            storeData.background2Unlocked = true;
            saveStoreData();
            updateStoreUI();
            addNotification("Background Music 2 Unlocked!");
          } else {
            alert("Not enough currency or already unlocked!");
          }
        });

      document.getElementsByName("bgMusic").forEach((radio) => {
        radio.addEventListener("change", (e) => {
          const localTrackContainer = document.getElementById("localTrackContainer");
          if (e.target.value === "default") {
            backgroundMusic.src = "sounds/background.mp3";
            localTrackContainer.style.display = "none";
            backgroundMusic.play();
          } else if (e.target.value === "background2") {
            backgroundMusic.src = "sounds/background2.mp3";
            localTrackContainer.style.display = "none";
            backgroundMusic.play();
          } else if (e.target.value === "custom") {
            localTrackContainer.style.display = "block";
          }
        });
      });

      document.getElementById("localTrackInput").addEventListener("change", function (e) {
        const file = e.target.files[0];
        if (file) {
          const objectUrl = URL.createObjectURL(file);
          backgroundMusic.src = objectUrl;
          backgroundMusic.load();
          if (audioCtx && audioCtx.state === "suspended") {
            audioCtx.resume();
          }
          backgroundMusic.play();
          addNotification("Custom track loaded!");
        }
      });

      startBtn.addEventListener("click", () => {
        tutorialEl.style.display = "none";
        lastTime = 0;
        if (audioCtx && audioCtx.state === "suspended") {
          audioCtx.resume();
        }
        if (backgroundMusic?.currentTime) {
          backgroundMusic.currentTime = 0;
        }
        backgroundMusic.play();
        animate(0);
      });

      restartBtn.addEventListener("click", () => {
        if (score > storeData.highScore) {
          storeData.highScore = score;
          saveStoreData();
        }
        cancelAnimationFrame(animationId);
        storeData.currency += score;
        saveStoreData();
        score = 0;
        comboCount = 0;
        comboTimer = 0;
        gameSpeed = 1;
        gameOver = false;
        currentLevel = 1;
        currentBoss = null;
        player = new Player();
        background = new Background();
        city = new City();
        fireBubbles = [];
        obstacles = [];
        waterProjectiles = [];
        boostPickups = [];
        hoseUpgrades = [];
        laserPickups = [];
        shieldPickups = [];
        cityHealthPickups = [];
        electricHosePickups = [];
        bombPickups = [];
        lifeShieldPickups = [];
        playerHealthPickups = []; // New array
        particles = [];
        notifications = [];
        scorePopups = [];
        bubbleTimer = 0;
        obstacleTimer = 0;
        boostTimer = 7000;
        bubbleInterval = 1000;
        obstacleInterval = 3000;
        gameOverEl.style.display = "none";
        lastTime = 0;
        if (backgroundMusic && typeof backgroundMusic.currentTime !== "undefined") {
          if (backgroundMusic?.currentTime) {
            backgroundMusic.currentTime = 0;
          }
        }
        backgroundMusic.play();
        animate(0);
        levelStartScore = 0;
        nextLevelThreshold = 1000;
      });

      document.getElementById("storeBtn").addEventListener("click", () => {
        if (score > storeData.highScore) {
          storeData.highScore = score;
          saveStoreData();
        }
        cancelAnimationFrame(animationId);
        storeData.currency += score;
        saveStoreData();
        score = 0;
        comboCount = 0;
        comboTimer = 0;
        gameSpeed = 1;
        gameOver = false;
        currentLevel = 1;
        currentBoss = null;
        player = new Player();
        background = new Background();
        city = new City();
        fireBubbles = [];
        obstacles = [];
        waterProjectiles = [];
        boostPickups = [];
        hoseUpgrades = [];
        laserPickups = [];
        shieldPickups = [];
        cityHealthPickups = [];
        electricHosePickups = [];
        bombPickups = [];
        lifeShieldPickups = [];
        playerHealthPickups = []; // New array
        particles = [];
        notifications = [];
        scorePopups = [];
        bubbleTimer = 0;
        obstacleTimer = 0;
        boostTimer = 7000;
        bubbleInterval = 1000;
        obstacleInterval = 3000;
        gameOverEl.style.display = "none";
        backgroundMusic.pause();
        updateStoreUI();
        tutorialEl.style.display = "flex";
        levelStartScore = 0;
        nextLevelThreshold = 1000;
      });

      // Start Button: Initialize audio on user gesture.
      startBtn.addEventListener("click", () => {
        tutorialEl.style.display = "none";
        lastTime = 0;
        if (!audioCtx) {
          initAudio();
        }
        if (audioCtx && audioCtx.state === "suspended") {
          audioCtx.resume();
        }
        if (
          backgroundMusic &&
          typeof backgroundMusic.currentTime !== "undefined"
        ) {
          if (backgroundMusic?.currentTime) {
            backgroundMusic.currentTime = 0;
          }
        }
        backgroundMusic.play();
        animate(0);
      });

      updateStoreUI();

      // Boss Class
      class Boss {
        constructor(level) {
          this.level = level;
          this.art = bosses[level].art;
          this.maxHealth = bosses[level].health;
          this.health = this.maxHealth;
          this.x = canvas.width - 150;
          this.y = canvas.height / 2 - 30;
          this.pattern = bosses[level].pattern;
          this.speed = 2;
          this.phase = 0;
          this.attackTimer = 0;
          this.attackInterval = 2000;
          this.isActive = false;
          this.hitFlash = 0;
        }

        update(deltaTime) {
          if (!this.isActive) return;

          // Movement patterns
          switch (this.pattern) {
            case "linear":
              this.y += Math.sin(this.phase) * this.speed;
              this.phase += 0.02;
              break;
            case "sine":
              this.y = canvas.height/2 + Math.sin(this.phase) * 100;
              this.phase += 0.03;
              break;
            case "spiral":
              this.x = canvas.width - 150 + Math.cos(this.phase) * 50;
              this.y = canvas.height/2 + Math.sin(this.phase) * 50;
              this.phase += 0.04;
              break;
          }

          // Keep boss in bounds
          if (this.y < 50) this.y = 50;
          if (this.y > canvas.height - 100) this.y = canvas.height - 100;

          // Attack logic
          this.attackTimer += deltaTime;
          if (this.attackTimer >= this.attackInterval) {
            this.attack();
            this.attackTimer = 0;
          }

          // Hit flash effect
          if (this.hitFlash > 0) {
            this.hitFlash -= deltaTime;
          }
        }

        draw() {
          if (!this.isActive) return;

          // Draw health bar
          const healthBarWidth = 100;
          const healthPercentage = this.health / this.maxHealth;
          ctx.fillStyle = "red";
          ctx.fillRect(this.x, this.y - 20, healthBarWidth, 5);
          ctx.fillStyle = "green";
          ctx.fillRect(this.x, this.y - 20, healthBarWidth * healthPercentage, 5);

          // Draw boss with hit flash effect
          const color = this.hitFlash > 0 ? "#ff0000" : "#ffffff";
          drawAsciiArt(this.art, this.x, this.y, 20, color);
        }

        attack() {
          switch (this.level) {
            case 1:
              // Level 1 boss shoots 3 fire bubbles in a spread
              for (let i = -1; i <= 1; i++) {
                let fire = new FireBubble("normal");
                fire.x = this.x;
                fire.y = this.y + (i * 30);
                fire.speed *= 1.5;
                fireBubbles.push(fire);
              }
              break;
            case 2:
              // Level 2 boss alternates between normal and electrical fires
              for (let i = -2; i <= 2; i++) {
                let fire = new FireBubble(i % 2 === 0 ? "normal" : "electrical");
                fire.x = this.x;
                fire.y = this.y + (i * 25);
                fire.speed *= 1.75;
                fireBubbles.push(fire);
              }
              break;
            case 3:
              // Level 3 boss creates a spiral pattern of fires
              for (let i = 0; i < 8; i++) {
                let angle = (i / 8) * Math.PI * 2;
                let fire = new FireBubble(i % 2 === 0 ? "normal" : "electrical");
                fire.x = this.x + Math.cos(angle) * 50;
                fire.y = this.y + Math.sin(angle) * 50;
                fire.speed *= 2;
                fireBubbles.push(fire);
              }
              break;
          }
        }

        hit(damage) {
          this.health -= damage;
          this.hitFlash = 100;
          // Add points for hitting the boss
          addScore(5);  // Use addScore for boss hits
          if (this.health <= 0) {
            this.defeat();
          }
        }

        defeat() {
          this.isActive = false;
          spawnParticles(this.x, this.y, "255,255,0", 100);
          const bossBonus = 1000 * this.level;
          addScore(bossBonus);  // Use addScore for consistency
          storeData.currency += 500 * this.level;
          addNotification(`Boss ${this.level} Defeated! +${bossBonus} Score!`);
          
          if (this.level < MAX_LEVELS) {
            currentLevel = Math.min(currentLevel + 1, MAX_LEVELS);
            currentLevelScore = 0;  // Reset score for new level
            bossSpawned = false;
            currentBoss = null;
            // Reset game speed for new level
            gameSpeed = LEVEL_SPEEDS[currentLevel] || 1.0;
            showLevelModal(currentLevel);
            // Reset level parameters
            bubbleTimer = 0;
            obstacleTimer = 0;
            fireBubbles = [];
            obstacles = [];
          } else {
            // Handle game completion
            addNotification("Congratulations! You've completed all levels!");
            gameOver = true;
            backgroundMusic.pause();
            gameOverText.textContent = "Victory! Final Score: " + score;
          }
        }
      }

      let currentBoss = null;

      // Update the powerup duration calculations
      function getPowerupDuration() {
        const baseDuration = 5000;
        const durationMultiplier = 1 + (storeData.powerupDurationTier * 0.5); // 50% increase per tier
        return baseDuration * durationMultiplier;
      }

      document.getElementById("upgradeBaseHealthBtn").addEventListener("click", () => {
        if (storeData.baseHealthTier < 3) {
          let cost = 1000 * Math.pow(2, storeData.baseHealthTier);
          if (storeData.currency >= cost) {
            storeData.currency -= cost;
            storeData.baseHealthTier++;
            player.maxLives = 3 + storeData.baseHealthTier;
            player.lives = Math.min(player.lives + 1, player.maxLives);
            saveStoreData();
            updateStoreUI();
            addNotification("Base Health Upgraded! Maximum Lives: " + player.maxLives);
          } else {
            alert("Not enough currency!");
          }
        } else {
          alert("Base Health is fully upgraded!");
        }
      });

      document.getElementById("upgradePickupSizeBtn").addEventListener("click", () => {
        if (storeData.pickupSizeTier < 2) {
          let cost = 1500 * Math.pow(2, storeData.pickupSizeTier);
          if (storeData.currency >= cost) {
            storeData.currency -= cost;
            storeData.pickupSizeTier++;
            saveStoreData();
            updateStoreUI();
            addNotification("Pickup Size Upgraded!");
          } else {
            alert("Not enough currency!");
          }
        } else {
          alert("Pickup Size is fully upgraded!");
        }
      });

      document.getElementById("upgradePowerupDurationBtn").addEventListener("click", () => {
        if (storeData.powerupDurationTier < 3) {
          let cost = 2000 * Math.pow(2, storeData.powerupDurationTier);
          if (storeData.currency >= cost) {
            storeData.currency -= cost;
            storeData.powerupDurationTier++;
            saveStoreData();
            updateStoreUI();
            addNotification("Powerup Duration Upgraded!");
          } else {
            alert("Not enough currency!");
          }
        } else {
          alert("Powerup Duration is fully upgraded!");
        }
      });

      // Game initialization
      window.onload = function() {
        // Initialize player
        player = new Player();
        
        // Initialize game loop
      };

      // Remove duplicate declarations at line 1039 and 1225
      function startGame() {
        // Update values without redeclaring
        player = new Player();
        currentLevel = 1;
        // ... rest of startGame function
      }

      // In the reset function, update instead of redeclare
      function reset() {
        // Remove any existing level modals to prevent duplicates
        document.querySelectorAll('.level-modal').forEach(modal => modal.remove());
        // Update existing variables instead of redeclaring
        score = 0;  // Reset overall score
        currentLevelScore = 0;  // Reset current level score
        comboCount = 0;
        currentLevel = 1;
        player = new Player();
        notifications = [];
        gameOver = false;
        isPaused = false;
        levelTransitionActive = false;
        bossSpawned = false;
        currentBoss = null;
        
        // ... rest of reset function ...
      }

      class PlayerHealthPickup {
        constructor() {
          this.x = canvas.width + 30;
          this.y = Math.random() * (canvas.height - 30);
          this.speed = gameSpeed;
          this.rotation = 0;
        }
        update(deltaTime) {
          this.x -= this.speed;
          this.rotation += deltaTime * 0.005;
          this.draw();
        }
        draw() {
          drawRotatingGlowingText(ctx, "üíù", this.x, this.y, "20px monospace", "#ff1493", this.rotation);
        }
      }

      function addScore(points) {
        score += points * (comboCount || 1);  // Add to overall score with combo multiplier
        currentLevelScore += points;  // Add to current level score WITHOUT multiplier
        scoreEl.textContent = score;  // Update overall score display
        
        // Check for boss spawn based on current level score
        const levelThreshold = LEVEL_SCORE_THRESHOLDS[currentLevel] || 1000;
        if (currentLevelScore >= levelThreshold && !bossSpawned && currentLevel <= MAX_LEVELS) {
          bossSpawned = true;
          currentBoss = new Boss(Math.min(currentLevel, MAX_LEVELS));
          currentBoss.isActive = true;
          // Add dramatic notifications for boss approach
          addNotification(`‚ö†Ô∏è WARNING: Level ${currentLevel} Boss Approaching! ‚ö†Ô∏è`);
          addNotification(`Prepare for Battle!`);
          // Play a warning sound if you have one
          if (explosionSound) {
            explosionSound.currentTime = 0;
            explosionSound.play();
          }
        }
      }

      // Add pause functionality
      document.getElementById("pauseBtn").addEventListener("click", () => {
        isPaused = !isPaused;
        const pauseBtn = document.getElementById("pauseBtn");
        const pauseMenu = document.getElementById("pauseMenu");
        
        if (isPaused) {
          cancelAnimationFrame(animationId);
          pauseBtn.textContent = "‚ñ∂Ô∏è";
          pauseMenu.style.display = "flex";
          if (backgroundMusic) backgroundMusic.pause();
        } else {
          pauseBtn.textContent = "‚è∏Ô∏è";
          pauseMenu.style.display = "none";
          if (backgroundMusic) backgroundMusic.play();
          animate(0);
        }
        // Prevent button from getting focus
        pauseBtn.blur();
        // Return focus to canvas
        canvas.focus();
      });

      // Prevent spacebar from triggering buttons
      document.addEventListener('keydown', function(e) {
        if (e.code === 'Space') {
          e.preventDefault();
        }
      });

      // Keep canvas focusable
      canvas.tabIndex = 1;
      canvas.style.outline = 'none';
      
      // Update resume button to also handle focus
      document.getElementById("resumeBtn").addEventListener("click", () => {
        isPaused = false;
        const pauseBtn = document.getElementById("pauseBtn");
        pauseBtn.textContent = "‚è∏Ô∏è";
        document.getElementById("pauseMenu").style.display = "none";
        if (backgroundMusic) backgroundMusic.play();
        animate(0);
        // Prevent button from getting focus and return to canvas
        pauseBtn.blur();
        canvas.focus();
      });

      // Add quit to menu functionality with focus handling
      document.getElementById("quitToMenuBtn").addEventListener("click", () => {
        isPaused = false;
        document.getElementById("pauseMenu").style.display = "none";
        reset();
        updateStoreUI();
        // Return focus to canvas
        canvas.focus();
      });

    </script>
  </body>
</html>
